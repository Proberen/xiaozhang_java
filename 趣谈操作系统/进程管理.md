## 1 进程

### 1.1 写代码：用系统调用创建进程

**1、创建文本文件，写入创建进程逻辑**

- `fork`系统调用，fork的返回值不同，父进程和子进程分道扬镳了
- 在子进程，需要通过`execvp`运行新的程序

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

extern int create_process (char* program, char** arg_list);

int create_process (char* program, char** arg_list)
{
  pid_t child_pid;
  child_pid = fork ();
  if (child_pid != 0)
    return child_pid;
  else {
    execvp (program, arg_list);
    abort ();
  }
}
```

**2、创建第二个文件，调用上面的函数**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

extern int create_process (char* program, char** arg_list);

int main ()
{
  char* arg_list[] = {
    "ls",
    "-l",
    "/etc/yum.repos.d/",
    NULL
  };
  # 调用函数运行ls命令
  create_process ("ls", arg_list);
  return 0;
}
```

### 1.2 编译：程序的二进制格式

> CPU无法执行文本文件的指令，CPU能够执行的指令是二进制的，所以需要对指令进行翻译，翻译的过程为**编译（Complie）**

**1、ELF（Executeable and Linkable Format，可执行与可链接格式）**

- 在Linux下，二进制的程序需要有严格的格式ELF，这个格式可以根据编译的结果不同分为不同的格式

**2、文本文件编译为二进制格式过程**

<img src="https://img-blog.csdnimg.cn/f9c86470b81f41f1b4ca28d1bb99648d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

- **头文件**：上面代码的include部分
- **源文件**：这个.c结尾的文件

- **.o文件**：可重定位文件（Relocatable File）

  - 头部：描述整个文件
  - .text：存放编译好的二进制可执行代码
  - .data：存放已经初始化的全局变量
  - .rodata：只读数据，例如字符串常量、const 的变量
  - .bss：未初始化全局变量，运行时会置 0
  - .symtab：符号表，记录的则是函数和变量
  - .strtab：字符串表、字符串常量和变量名
  - 节头部标：存放节的元数据

  > 为什么叫重定位文件？
  >
  > 文件存放的地址都是相对地址

  <img src="https://img-blog.csdnimg.cn/51401353143e49359bad943056711737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" />

- **可执行文件**：ELF的第二种格式

  - 可以马上加载到内存里面执行

  <img src="https://img-blog.csdnimg.cn/a02c905bbd874619a4e771e18df1c387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" />

- **动态链接库**：ELF的第三种格式，**共享对象文件（Shared Object）**

### 1.3 运行程序为进程

> ELF这个格式的文件如何加载到内存？

在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。

```c
struct linux_binfmt { 
  struct list_head lh; 
  struct module *module; 
  int (*load_binary)(struct linux_binprm *); 
  int (*load_shlib)(struct file *); 
  int (*core_dump)(struct coredump_params *cprm); 
  unsigned long min_coredump; /* minimal dump size */
} __randomize_layout;
```

对于 ELF 文件格式，有对应的实现。

```c
static struct linux_binfmt elf_format = {
  .module = THIS_MODULE, 
  .load_binary = load_elf_binary, 
  .load_shlib = load_elf_library, 
  .core_dump = elf_core_dump, 
  .min_coredump = ELF_EXEC_PAGESIZE,
};
```

 load_elf_binary是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。

还记得当时是谁调用的 load_elf_binary 函数吗？具体是这样的：do_execve->do_execveat_common->exec_binprm->search_binary_handler。

那 do_execve 又是被谁调用的呢？我们看下面的代码。

```c
SYSCALL_DEFINE3(execve, 
                const char __user *, filename, 
                const char __user *const __user *, argv, 
                const char __user *const __user *, envp)
{ 
  return do_execve(getname(filename), argv, envp);
}
```

学过了系统调用一节，你会发现，原理是 exec 这个系统调用最终调用的 load_elf_binary。

exec 比较特殊，它是一组函数：

- 包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；
- 不包含 p 的函数需要输入程序的全路径；
- 包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；
- 包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；
- 包含 e 的函数（execve, execle）以数组的形式接收环境变量。

在上面 process.c 的代码中，我们创建 ls 进程，也是通过 exec。

### 1.4 进程树

既然所有的进程都是从父进程 fork 过来的，那总归有一个祖宗进程，这就是咱们系统启动的 init 进程。

<img src="https://img-blog.csdnimg.cn/9ea0a6a122574a41b4e7b685d8e9b00e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 1.5 总结

这一节我们讲了一个进程从代码到二进制到运行时的一个过程，我们用一个图总结一下。

我们首先通过图右边的文件编译过程，生成 so 文件和可执行文件，放在硬盘上。下图左边的用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。这个系统调用会通过 load_elf_binary 方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d79bef49dc9d4b09bbcb147867700276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)



## 2 线程

### 2.1 为什么需要线程？

1、对于任何一个进程，即使没有主动创建线程，**进程也默认拥有一个主线程**

2、线程是负责执行二进制指令的，进程除了执行指令外，内存、文件系统都需要管

**3、使用进程实现并行执行问题的问题：**

- 创建进程占用资源太多
- 进程之间通信需要数据在不同的内存空间传来传去，无法共享

**4、需要线程的原因**

- 并行执行
- 需要处理应急的事情
- 分离前台任务和后台任务

### 2.2 如何创建线程？



<img src="https://img-blog.csdnimg.cn/c2cf38e262914aa4b1b392f7c1514791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 2.3 线程的数据

> 过程并行起来了，数据呢？

将线程访问的数据分为三类：

- 线程中的局部变量
- 进程中的全局变量
- 线程中的全局变量

<img src="https://img-blog.csdnimg.cn/f3c383bfe9e94205a048dfb1a087f957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**1、线程栈上的本地数据**

- 栈的大小可以使用命令`ulimit -a`查看，默认情况下线程栈大小为8M
- 主线程在内存中有一个栈空间，其他线程也有独立的栈空间
- 为了避免线程之间的**栈空间踩踏**，线程栈之间会有小块区域来隔离保护各自的栈空间，一旦另外一个线程踏入到这个隔离区，会引发段错误

**2、进程共享的全局数据**

- 在不同进程间是隔离的，在一个进程中是共享的
- 多个线程一起修改同一个全局变量，需要一个机制来保护他们

**3、线程私有数据**（类似ThreadLocal）

- 弥补进程共享和线程内函数共享之间的空白

- 通过以下函数创建：

  ```c
  int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
  ```

  - 创建一个key，伴随一个析构函数；key一旦被创建所有的线程都可以访问，但是各个线程可以根据自己的需要向key中填入不同的值，就提供了一个**同名而不同值的全局变量**

  - 可以通过以下函数设置key对应的value

    ```c
    int pthread_setspecific(pthread_key_t key, const void *value)
    ```

### 2.4 数据的保护

**Mutex（Mutual Exclusion，互斥）**

<img src="https://img-blog.csdnimg.cn/b1038f88381343bb9f5a378076e4d407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 3 进程数据结构

> 在Linux里，无论是进程还是线程，到了内核中统一称为任务，由统一的结构**task_struct**管理

<img src="https://img-blog.csdnimg.cn/0ff7f939f30c4c00b0805bc272ef5512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**任务列表：使用链表将所有的task_struct串起来**

### 3.1 任务

#### 3.1.1 任务ID

1、每个任务都有一个ID作为这个任务的唯一标识

2、task_struct里面涉及任务ID的有下面几个：

```c
pid_t pid;
pid_t tgid;
struct task_struct *group_leader; 
```

**3、为什么需要这么多？进程和线程到内核中统一变成了任务，存在两个问题：**

- **任务展示**
  - 如果按照任务列表将所有的线程都展示给用户，会比较复杂
  - 用户无法找到那些自己创建的线程
- **给任务下发指令**
  - 比如需要终止某个任务，应该给进程下发信号，退出进程下的所有线程

**4、在内核中需要对线程和进程进行区分**

- `pid`：process id
- `tgid`：thread group id
- **任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己（pid=tgid=group_leader）**
- **如果一个进程创建了其他线程，线程有自己的pid，tgid=主线的的pid，group_leader指向主线程**

#### 3.1.2 信号处理

1、关于信号处理的字段

```c
/* Signal handlers: */
struct signal_struct    *signal;
struct sighand_struct    *sighand;
sigset_t      blocked;
sigset_t      real_blocked;
sigset_t      saved_sigmask;
struct sigpending    pending;
unsigned long      sas_ss_sp;
size_t        sas_ss_size;
unsigned int      sas_ss_flags;
```

这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。

信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是 sas_ss_xxx 这三个变量的作用。

上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。

task_struct 里面有一个 struct sigpending pending。如果我们进入 struct signal_struct *signal 去看的话，还有一个 struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。

#### 3.1.3 任务状态

1、涉及任务状态的字段

```c
volatile long state; /* -1 unrunnable, 0 runnable, >0 stopped */ int exit_state; 
unsigned int flags;
```

state是通过bitset的方式设置的，当前是什么状态哪一位就是1

<img src="https://img-blog.csdnimg.cn/a208a5095b3a45e499a6379e5843e119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



**2、TASK_RUNNING**

- 进程在时刻准备运行（**就绪状态**）
- 当处于这个状态的进程获取时间片的时候就是在运行中，没有获取到就说明被其他进程抢占了，在等待再次分配时间片
- 运行的进程一旦需要进行IO操作，需要等待IO完毕，这个时候会释放CPU，进入睡眠状态

**3、TASK_INTERRUPTIBLE**

- 可中断的睡眠
- 浅睡眠的状态
- 这个时候一个信号来的时候进程要被唤醒，唤醒后不继续刚才的操作，而是进行**信号处理**
  - 例如：收到某些信号就放弃等待这个I/O操作完成，直接退出

**4、TASK_UNINTERRUPTIBLE**

- 不可中断的睡眠
- 深度睡眠状态
- 不能被信号唤醒，死等I/O结束
  - kill信号也会被忽略

**5、TASK_KILLABLE**

- 可终止的睡眠
- 运行原理类似于TASK_UNINTERRUPTIBLE，但是可以响应致命信号

**6、TASK_STOPPED**

- 收到sigstop、sigttin、sigtstp、sigttou信号后进入该状态

**7、EXIT_ZOMBIE**

- 一旦一个进程要结束，先进入EXIT_ZOMBIE状态，但是这个时候它的父进程没有使用wait()等系统调用获取它的终止信息，此时进程变成了**僵尸进程**

#### 3.1.4 进程调度

1、进程的状态切换涉及调度，下面字段用于调度

```c
//是否在运行队列上
int        on_rq;
//优先级
int        prio;
int        static_prio;
int        normal_prio;
unsigned int      rt_priority;
//调度器类
const struct sched_class  *sched_class;
//调度实体
struct sched_entity    se;
struct sched_rt_entity    rt;
struct sched_dl_entity    dl;
//调度策略
unsigned int      policy;
//可以使用哪些CPU
int        nr_cpus_allowed;
cpumask_t      cpus_allowed;
struct sched_info    sched_info;
```

### 3.2 总结

![在这里插入图片描述](https://img-blog.csdnimg.cn/7e270117112046418e017780d348d470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

