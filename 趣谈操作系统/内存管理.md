## 1 内存管理

### 1.1 独享内存空间

1、每个项目的物理地址对于进程来说不可见，操作系统会给进程分配一个虚拟地址，所有进程看到的地址都是一样的，里面的内存都是从0开始的

2、在程序里面，指令写入的地址是虚拟地址。例如，位置为 10M 的内存区域，操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

3、当程序要访问虚拟地址的时候，**由内核的数据结构进行转换，转换成不同的物理地址**，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。

### 1.2 规划虚拟地址空间

1、操作系统的内存管理，主要分为三个方面：

- 物理内存的管理
- 虚拟地址的管理
- 虚拟地址和物理内存如何映射

**2、物理内存的访问都是通过内存管理，不管是用户态还是内核态都是访问虚拟内存，通过内存管理映射到物理内存**

**3、站在一个进程的角度去看这个虚拟的空间：**

- 如果是32位，那么有4G的内存空间是我的；如果是64位，在x86_64下，实际上只使用48位，对应256TB空间；
- **OS将虚拟空间分为两部分**：内核空间（地址在上）、用户空间（地址在下）；对于普通进程，内核空间不能访问

![在这里插入图片描述](https://img-blog.csdnimg.cn/fe446777464b4979bf7a5cd2575e5707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

- 从最低位开始，先是 **Text Segment（存放二进制可执行代码）、Data Segment（静态常量） 和 BSS Segment（未初始化的静态变量）**
- **堆（Heap）**：动态分配内存的区域
- **Memory Mapping Segment**：把文件映射进内存，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中
- **栈（stack）**：主线程的函数调用的函数栈
  - **主线程**函数调用，使用的是进程里的栈空间
  - **主线程之外的线程**，使用的函数栈是在进程的**堆空间**里分配的一段内存作为函数栈使用

- 对于内核空间，无论是哪个进程进来的都是看见同一个内核空间，同一个进程列表。虽然内核栈不同，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/b2debebb26a6400d917c498997e13852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

### 1.3 虚拟地址映射物理地址

#### 1.3.1 **分段机制**

<img src="https://img-blog.csdnimg.cn/445e38e6e8614136ae6bb4471bd0a55f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

1、分段机制下虚拟地址由两部分组成：**段选择子和段内偏移量**

- **段选择子**：保存在段寄存器，最重要的是**段号**，用作**段表**的索引
- **段内偏移量**：位于0到段界限之间

2、**段表**：保存段的**基地址、段的界限和特权等级**等

> **段的物理内存地址=基地址+段内偏移量**

3、分段的问题：

- 内存碎片
- 内存交换效率低

4、在Linux中，段表称为**段描述符表**，放在**全局描述符表GDT**里面

- 表项包括**基地址base、段界限limit、其他标识符**
- 分析发现，所有段的起始地址都是一样的，都是0，所以在Linux系统中没有使用到全部的分段功能，**分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。**
- **Linux只使用分段做权限审核**

#### **1.3.2 分页（paging）**

1、对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理

- **换出**：有的内存页面长时间不用了，可以暂时写到硬盘上
- **换入**：一旦需要的时候，再加载进来，这样可以扩大可用物理内存的大小，提高物理内存的利用率
- **换入和换出都是以页为单位的，页面的大小一般为 4KB**

<img src="https://img-blog.csdnimg.cn/8fede829163d4144876cbf14665fbb33.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

2、虚拟地址分为两部分：**页号、页内偏移量**

3、页表：**物理页每页所在物理内存的地址、基地址**

- 页表中所有页表项需要**提前建立并且连续**
- 页表存储在**内存管理单元（MMU）**

**4、分页如何解决分段的内存碎片、内存交换效率低的问题？**

- 释放内存都是以页为单位释放的
- 如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给换出（*Swap Out*）。一旦需要的时候，再加载进来，称为**换入**（*Swap In*）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，**内存交换的效率就相对比较高**
- 分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是**只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。**

**5、简单的分页存在的问题？**

- 空间上的缺陷
  - 操作系统可以同时运行非常多的进程，就意味着页表非常庞大；在32位环境下虚拟地址空间共有4GB，假设一个页大小为4KB，就需要100万个页，每个页表项需要4个字节大小存储，那么4G空间的映射需要4MB的内存来存储页表。每个进程都需要一个页表，那么这就很占用内存。

- **解决：多级页表**

  - 把这100万个页表项的单级页表再分页，分为1024个页表（二级），每个表（二级）包含1024个页表项，形成二级分页

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/edccc53b24264751a540c3c5d7b30ee8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)
  - **如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**
  - **页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项**
  - 对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：
    - 全局页目录项 PGD（*Page Global Directory*）
    - 上层页目录项 PUD（*Page Upper Directory*）
    - 中间页目录项 PMD（*Page Middle Directory*）
    - 页表项 PTE（*Page Table Entry*）

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/4803a0cdfb8a4c71bcc09f18db7db723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)
  - 虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了**时间上的开销**

    - 解决：将常用页表项放入Cache（**TLB**），称为**快表**
    - 有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个

    <img src="https://img-blog.csdnimg.cn/0595ba75dd2b4484af495cbc9de6b2bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" />

    - CPU读取数据的流程：

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/eba81f28500046b5993a855f505ce41c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

    - 进行上下文切换的时候，TLB放的是上一个进程的相关地址，刷新数据的方式：

      - 全部刷新
      - 部分刷新

#### 1.3.3 段页式内存管理

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为**段页式内存管理**。

<img src="https://img-blog.csdnimg.cn/510de8e738fc423aa453a8ce499023a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" />

**1、页式内存管理实现的方式：**

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；
- 地址结构就由**段号、段内页号和页内位移**三部分组成
- 用于段页式地址变换的数据结构是**每一个程序一张段表**，**每个段又建立一张页表**，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/00a51c63a8364c6dacee4b7ea3a1ae88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)



- 访问物理地址需要经过三次内存访问
  - 第一次访问段表，得到页表起始地址
  - 第二次访问页表，得到物理页号
  - 第三次将物理页号与页内偏移组合，得到物理地址

#### 1.3.4 Linux内存管理

**1、Intel处理器的发展历史**

早期 Intel 的处理器从 80286 开始使用的是**段式内存管理**。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。

因此，在不久以后的 80386 中就实现了对**页式内存管理**。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，**页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。**由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。

于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6c6b00cd49d843d997e3d7da84759910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)



逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址

**2、Linux采用什么方式管理内存？**

- 主要采用**页式内存管理**，但是涉及了**段机制**
- 原因： Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射
- 对策：**Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。**

- 虚拟地址空间分布：
  - 分为**内核空间**和**用户空间**



## 2 进程空间管理

### 2.1 用户态和内核态的划分

整个虚拟内存空间分为：

- 用户态地址空间
- 内核态地址空间

> 对于32位系统，最大寻址2^32=4G，其中用户态虚拟地址空间3G，内核态1G
>
> 对于64位系统，虚拟地址使用48位

<img src="https://img-blog.csdnimg.cn/bc510627a2634505951c9e422f07c5fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 2.2 用户态布局

用户态虚拟空间有几类数据，例如**代码、全局变量、堆、栈、内存映射区**等

<img src="https://img-blog.csdnimg.cn/fb3c35a94c224e07a17d889ca8e95dc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />



























