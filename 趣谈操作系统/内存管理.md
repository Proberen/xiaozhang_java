## 1 内存管理

### 1.1 独享内存空间

1、每个项目的物理地址对于进程来说不可见，操作系统会给进程分配一个虚拟地址，所有进程看到的地址都是一样的，里面的内存都是从0开始的

2、在程序里面，指令写入的地址是虚拟地址。例如，位置为 10M 的内存区域，操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

3、当程序要访问虚拟地址的时候，**由内核的数据结构进行转换，转换成不同的物理地址**，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。

### 1.2 规划虚拟地址空间

1、操作系统的内存管理，主要分为三个方面：

- 物理内存的管理
- 虚拟地址的管理
- 虚拟地址和物理内存如何映射

**2、物理内存的访问都是通过内存管理，不管是用户态还是内核态都是访问虚拟内存，通过内存管理映射到物理内存**

**3、站在一个进程的角度去看这个虚拟的空间：**

- 如果是32位，那么有4G的内存空间是我的；如果是64位，在x86_64下，实际上只使用48位，对应256TB空间；
- **OS将虚拟空间分为两部分**：内核空间（地址在上）、用户空间（地址在下）；对于普通进程，内核空间不能访问

![在这里插入图片描述](https://img-blog.csdnimg.cn/fe446777464b4979bf7a5cd2575e5707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

- 从最低位开始，先是 **Text Segment（存放二进制可执行代码）、Data Segment（静态常量） 和 BSS Segment（未初始化的静态变量）**
- **堆（Heap）**：动态分配内存的区域
- **Memory Mapping Segment**：把文件映射进内存，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中
- **栈（stack）**：主线程的函数调用的函数栈
  - **主线程**函数调用，使用的是进程里的栈空间
  - **主线程之外的线程**，使用的函数栈是在进程的**堆空间**里分配的一段内存作为函数栈使用

- 对于内核空间，无论是哪个进程进来的都是看见同一个内核空间，同一个进程列表。虽然内核栈不同，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/b2debebb26a6400d917c498997e13852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

### 1.3 虚拟地址映射物理地址

#### 1.3.1 **分段机制**

<img src="https://img-blog.csdnimg.cn/445e38e6e8614136ae6bb4471bd0a55f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

1、分段机制下虚拟地址由两部分组成：**段选择子和段内偏移量**

- **段选择子**：保存在段寄存器，最重要的是**段号**，用作**段表**的索引
- **段内偏移量**：位于0到段界限之间

2、**段表**：保存段的**基地址、段的界限和特权等级**等

> **段的物理内存地址=基地址+段内偏移量**

3、分段的问题：

- 内存碎片
- 内存交换效率低

4、在Linux中，段表称为**段描述符表**，放在**全局描述符表GDT**里面

- 表项包括**基地址base、段界限limit、其他标识符**
- 分析发现，所有段的起始地址都是一样的，都是0，所以在Linux系统中没有使用到全部的分段功能，**分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。**
- **Linux只使用分段做权限审核**

#### **1.3.2 分页（paging）**

1、对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理

- **换出**：有的内存页面长时间不用了，可以暂时写到硬盘上
- **换入**：一旦需要的时候，再加载进来，这样可以扩大可用物理内存的大小，提高物理内存的利用率
- **换入和换出都是以页为单位的，页面的大小一般为 4KB**

<img src="https://img-blog.csdnimg.cn/8fede829163d4144876cbf14665fbb33.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

2、虚拟地址分为两部分：**页号、页内偏移量**

3、页表：**物理页每页所在物理内存的地址、基地址**

- 页表中所有页表项需要**提前建立并且连续**
- 页表存储在**内存管理单元（MMU）**

**4、分页如何解决分段的内存碎片、内存交换效率低的问题？**

- 释放内存都是以页为单位释放的
- 如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给换出（*Swap Out*）。一旦需要的时候，再加载进来，称为**换入**（*Swap In*）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，**内存交换的效率就相对比较高**
- 分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是**只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。**

**5、简单的分页存在的问题？**

- 空间上的缺陷
  - 操作系统可以同时运行非常多的进程，就意味着页表非常庞大；在32位环境下虚拟地址空间共有4GB，假设一个页大小为4KB，就需要100万个页，每个页表项需要4个字节大小存储，那么4G空间的映射需要4MB的内存来存储页表。每个进程都需要一个页表，那么这就很占用内存。

- **解决：多级页表**

  - 把这100万个页表项的单级页表再分页，分为1024个页表（二级），每个表（二级）包含1024个页表项，形成二级分页

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/edccc53b24264751a540c3c5d7b30ee8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)
  - **如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**
  - **页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项**
  - 对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：
    - 全局页目录项 PGD（*Page Global Directory*）
    - 上层页目录项 PUD（*Page Upper Directory*）
    - 中间页目录项 PMD（*Page Middle Directory*）
    - 页表项 PTE（*Page Table Entry*）

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/4803a0cdfb8a4c71bcc09f18db7db723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)
  - 虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了**时间上的开销**

    - 解决：将常用页表项放入Cache（**TLB**），称为**快表**
    - 有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个

    <img src="https://img-blog.csdnimg.cn/0595ba75dd2b4484af495cbc9de6b2bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" />

    - CPU读取数据的流程：

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/eba81f28500046b5993a855f505ce41c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

    - 进行上下文切换的时候，TLB放的是上一个进程的相关地址，刷新数据的方式：

      - 全部刷新
      - 部分刷新

#### 1.3.3 段页式内存管理

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为**段页式内存管理**。

<img src="https://img-blog.csdnimg.cn/510de8e738fc423aa453a8ce499023a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" />

**1、页式内存管理实现的方式：**

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；
- 地址结构就由**段号、段内页号和页内位移**三部分组成
- 用于段页式地址变换的数据结构是**每一个程序一张段表**，**每个段又建立一张页表**，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/00a51c63a8364c6dacee4b7ea3a1ae88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)



- 访问物理地址需要经过三次内存访问
  - 第一次访问段表，得到页表起始地址
  - 第二次访问页表，得到物理页号
  - 第三次将物理页号与页内偏移组合，得到物理地址

#### 1.3.4 Linux内存管理

**1、Intel处理器的发展历史**

早期 Intel 的处理器从 80286 开始使用的是**段式内存管理**。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。

因此，在不久以后的 80386 中就实现了对**页式内存管理**。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，**页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。**由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。

于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。

![在这里插入图片描述](https://img-blog.csdnimg.cn/6c6b00cd49d843d997e3d7da84759910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)



逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址

**2、Linux采用什么方式管理内存？**

- 主要采用**页式内存管理**，但是涉及了**段机制**
- 原因： Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射
- 对策：**Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。**

- 虚拟地址空间分布：
  - 分为**内核空间**和**用户空间**



## 2 进程空间管理

### 2.1 用户态和内核态的划分

整个虚拟内存空间分为：

- 用户态地址空间
- 内核态地址空间

> 内核进程和用户进程所占的虚拟内存比例是 1:3
>
> 对于32位系统，最大寻址2^32=4G，其中用户态虚拟地址空间3G，内核态1G
>
> 对于64位系统，虚拟地址使用48位



<img src="https://img-blog.csdnimg.cn/bc510627a2634505951c9e422f07c5fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 2.2 内核空间

内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数的。内核进程对应的虚拟内存，**按访问权限可以分为进程私有和进程共享两块区域**。

- **进程私有的虚拟内存**：每个进程都有单独的**内核栈、页表、task 结构以及 mem_map 结构**等。
- **进程共享的虚拟内存**：属于所有进程共享的内存区域，包括**物理存储器、内核数据和内核代码区域**。

### 2.3 用户空间

用户态虚拟空间有几类数据，例如**代码、全局变量、堆、栈、内存映射区**等

- **运行时栈**

  - 由编译器自动释放，存放**函数的参数值，局部变量和方法返回值**等。

  - 每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈顶，调用结束后调用信息会被弹出弹出并释放掉内存。
  - 栈区是从高地址位向低地址位增长的，是一块连续的内在区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。

- **运行时堆**

  - 存放进程运行中**被动态分配的内存段**，位于 BSS 和栈中间的地址位

  - 由卡发人员申请分配（malloc）和释放（free）
  - 堆是从低地址位向高地址位增长，采用链式存储结构。**频繁地 malloc/free 造成内存空间的不连续，产生大量碎片**。
  - 当申请堆空间时，库函数按照一定的算法搜索可用的足够大的空间。因此**堆的效率比栈要低的多**。

- **代码段**
  - 存放 CPU 可以执行的机器指令，该部分内存**只能读不能写**。
  - 通常代码区是共享的，即其它执行程序可调用它。假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。

- **未初始化的数据段**
  - 存放未初始化的全局变量，BSS 的数据在程序开始执行之前被初始化为 0 或 NULL。

- **已初始化的数据段**
  - 存放已初始化的全局变量，包括静态全局变量、静态局部变量以及常量。

- **内存映射区域**
  - 例如将动态库，共享内存等虚拟空间的内存映射到物理空间的内存，**一般是 mmap 函数所分配的虚拟内存空间**。

<img src="https://img-blog.csdnimg.cn/fb3c35a94c224e07a17d889ca8e95dc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />

## 3 虚拟内存和物理内存

### 3.1 物理内存

1、物理内存（Physical memory）是相对于虚拟内存（Virtual Memory）而言的。

2、物理内存指通过物理内存条而获得的内存空间，而虚拟内存则是指将硬盘的一块区域划分来作为内存。

**3、内存主要作用：在计算机运行时为操作系统和各种程序提供临时储存**。物理上真实存在的插在主板内存槽上的内存条的容量的大小。

### 3.2 虚拟内存

1、虚拟内存是计算机系统内存管理的一种技术。 **它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）**。实际上，虚拟内存通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换，加载到物理内存中来。 

**2、虚拟内存地址**

- 和用户进程紧密相关，一般来说不同进程里的同一个虚拟地址指向的物理地址是不一样的
- **每个进程所能使用的虚拟地址大小和 CPU 位数有关**。在 32 位的系统上，虚拟地址空间大小是 2 ^ 32 = 4G，在 64位系统上，虚拟地址空间大小是 2 ^ 64 = 2 ^ 34G，而实际的物理内存可能远远小于虚拟内存的大小。
- 每个用户进程维护了一个单独的页表（Page Table），虚拟内存和物理内存就是通过这个页表实现地址空间的映射的。

**3、用户进程申请并访问物理内存（或磁盘存储空间）的过程**

- 用户进程向操作系统发出内存申请请求

- 系统会检查进程的虚拟地址空间是否被用完，如果有剩余，给进程分配虚拟地址

- 系统为这块虚拟地址创建的内存映射（Memory Mapping），并将它放进该进程的页表（Page Table）

- 系统返回虚拟地址给用户进程，用户进程开始访问该虚拟地址

- CPU 根据虚拟地址在此进程的页表（Page Table）中找到了相应的内存映射（Memory Mapping），但是这个内存映射（Memory Mapping）没有和物理内存关联，于是产生**缺页中断**

- **操作系统收到缺页中断后**，分配真正的物理内存并将它关联到页表相应的内存映射（Memory Mapping）。中断处理完成后 CPU 就可以访问内存了

- 当然缺页中断不是每次都会发生，只有系统觉得有必要延迟分配内存的时候才用的着，也即很多时候在上面的第 3 步系统会分配真正的物理内存并和内存映射（Memory Mapping）进行关联。

**4、虚拟内存的优点**

- 地址空间：提供更大的地址空间，并且地址空间是连续的，使得程序编写、链接更加简单
- 进程隔离：不同进程的虚拟地址之间没有关系，所以一个进程的操作不会对其它进程造成影响
- 数据保护：每块虚拟内存都有相应的读写属性，这样就能保护程序的代码段不被修改，数据块不能被执行等，增加了系统的安全性
- 内存映射：有了虚拟内存之后，可以直接映射磁盘上的文件（可执行文件或动态库）到虚拟地址空间。这样可以做到物理内存延时分配，只有在需要读相应的文件的时候，才将它真正的从磁盘上加载到内存中来，而在内存吃紧的时候又可以将这部分内存清空掉，提高物理内存利用效率，并且所有这些对应用程序是都透明的
- 共享内存：比如动态库只需要在内存中存储一份，然后将它映射到不同进程的虚拟地址空间中，让进程觉得自己独占了这个文件。进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享
- 物理内存管理：物理地址空间全部由操作系统管理，进程无法直接分配和回收，从而系统可以更好的利用内存，平衡进程间对内存的需求





















