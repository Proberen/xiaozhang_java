## 1 文件系统

### 1.1 文件系统的功能规划

最常用的外部存储就是硬盘，数据以文件的形式保存在硬盘上，为了管理这些文件，在规划文件系统的时候需要考虑以下几点：

- 文件系统有**严格的组织形式**，使得文件能够以块为单位存储
- 文件系统也要有**索引区**，用来方便查找一个文件分成的多个块都存放在了什么位置
- 如果有热点文件，需要有**缓存**
- 文件应该使用**文件夹的形式组织起来**，方便管理查询
- Linux内核需要在内存里面**维护一套数据结构**，保存哪些文件被哪些进程打开和使用

### 1.2 文件系统相关命令行

**格式化**

- 将一块盘使用命令组织称一定格式的文件系统的过程
- Windows常用格式化格式为**NTFS**，Linux常用的是**ext3或者ext4**
- 当一个 Linux 系统插入了一块没有格式化的硬盘的时候，我们可以通过命令 `fdisk -l`，查看格式化和没有格式化的分区
- 可以通过命令 `mkfs.ext3` 或者 `mkfs.ext4` 进行格式化
- **格式化后的硬盘需要挂载到某个目录下才能作为普通的文件系统访问**

### 1.3 文件系统相关系统调用

**1、打开文件**

- 当使用系统调用open打开一个文件时，操作系统会创建一些数据结构来表示这个被打开的文件。在进程中，为这个打开的文件分配一个**文件描述符fd（File Descriptor）**

**2、文件描述符fd（File Descriptor）**

- 区分一个进程打开的多个文件
- **只在当前进程有效**
- open返回的fd必须记录好，我们对这个文件的所有操作都需要这个fd

**3、写入文件**

- **参数**
  - 文件描述符（你是谁？）
  - 表示写入的数据存放位置（你在哪里？）
  - 表示希望写入的字节数
- 返回值：成功写入文件的字节数量

<img src="https://img-blog.csdnimg.cn/696aa6549fc6425a84ac3e4d5d9096ef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" />

## 2 硬盘文件系统

> 主要讨论Linux下主流的文件系统格式——ext系列文件系统格式

### 2.1 inode与块的存储

1、硬盘被分成相同大小的单元，称为**块（block）**，一块的大小是扇区大小的整数倍（默认4k）

2、**inode**

- 存放文件的**元数据**，例如名字、权限等
- **每个文件都对应一个inode**，文件夹也是文件

- 数据结构：

  ```c
  struct ext4_inode {
    __le16  i_mode;    /* 读写权限 */
    __le16  i_uid;    /* 属于哪个用户 */
    __le16  i_gid;    /* 属于哪个组 */
    __le32  i_size_lo;  /* 大小 */
    
    __le32  i_atime;  /* 最近一次访问文件的时间 */
    __le32  i_ctime;  /* 最近一次更改inode的时间 */
    __le32  i_mtime;  /* 最近一次修改文件的时间，只有文件数据修改才会更新 */
    __le32  i_dtime;  /* Deletion Time */
    
    __le16  i_links_count;  /* Links count */
    __le32  i_blocks_lo;  /* 占多少个块 */
    __le32  i_flags;  /* File flags */
  ......
    __le32  i_block[EXT4_N_BLOCKS];/* 指向block */
    __le32  i_generation;  /* File version (for NFS) */
    __le32  i_file_acl_lo;  /* File ACL */
    __le32  i_size_high;
  ......
  };
  ```

**3、block是如何保存的？**

- EXT4_N_BLOCKS有如下定义：

  - 前12项保存块的位置，通过`i_block[0-11]`可以获取保存文件内容的块
  - 如果一个文件放不下的时候，就需要让`i_block[12]`指向一个**间接块**，存放数据块的位置
  - 如果文件再大一些，`i_block[13]`会指向一个块，可以用**二次间接块**，存放**间接块**的位置；再大就会使用`i_block[14]`指向**三次间接块**

  ```c
  #define  EXT4_NDIR_BLOCKS    12
  #define  EXT4_IND_BLOCK      EXT4_NDIR_BLOCKS
  #define  EXT4_DIND_BLOCK      (EXT4_IND_BLOCK + 1)
  #define  EXT4_TIND_BLOCK      (EXT4_DIND_BLOCK + 1)
  #define  EXT4_N_BLOCKS      (EXT4_TIND_BLOCK + 1)
  ```

  <img src="https://img-blog.csdnimg.cn/b5f0edf0b8824bb5ae2c67532cc15db8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" />
  - **问题**：对于大文件需要多次读取硬盘才能找到块，访问速度较慢

    - **解决**：ext4引入了**Extents**

      - 存放连续的块，保存为一颗树

      - 节点头**ext4_extent_header**：描述某个节点

        ```c
        struct ext4_extent_header {
          __le16  eh_magic; 
          __le16  eh_entries;  /* 表示这个节点有多少项，项分为两种，如果是叶子节点就直接指向硬盘上的连续块地址（ext4_extent），如果是分支节点就会指向下一层的节点（ext4_extent_idx） */
          __le16  eh_max;    
          __le16  eh_depth;  
          __le32  eh_generation; 
        };
        ```

      - inode里面的i_block可以放下一个1个header和4个extent；这个时候eh_depth位0

      - 如果文件比较大，4个extent放不下就需要分裂成一棵树，eh_depth>0的节点就是索引节点最底层eh_depth=0的是叶子节点

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/973e13c51d39429aa9dd4f67387bf3e4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

**4、inode位图和块位图**

- 文件系统中，专门有一个块来保存inode的位图，在这4k里面每一位对应一个inode。如果是1表示这个inode已经被使用了，如果是0就是没有被使用

### 2.2 文件系统的格式

**1、块组**

- 数据块的位图是放在一个块里面的，共4k。每位代表一个块，共可以表示 4∗1024∗8=215 个数据块。如果每个数据块也是按默认的 4K，最大可以表示空间为 215∗4∗1024=227 个 byte，也就是 128M。
- 如果采用**“一个块的位图 + 一系列的块”**，外加**“一个块的 inode 的位图 + 一系列的 inode 的结构”**，最多能够表示 128M，称为一个**块组**

2、**块组描述符表**

- 这样一个个块组，就基本构成了我们整个文件系统的结构。因为块组有多个，块组描述符也同样组成一个列表，我们把这些称为**块组描述符表**。

3、**超级块**（ext4_super_block）

- **对整个文件系统的情况进行描述**
- 这里面有整个文件系统一共有多少 inode，s_inodes_count；一共有多少块，s_blocks_count_lo，每个块组有多少 inode，s_inodes_per_group，每个块组有多少块，s_blocks_per_group 等。这些都是这类的全局信息。

**4、文件系统的格式**

- 引导块：系统启动时预留的一块区域
- 默认情况下，超级块和块组描述符表都有副本保存在每一个块组里面

![在这里插入图片描述](https://img-blog.csdnimg.cn/bc3342f2aabb409995f255507a582835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

- **问题**：如果每个块组都保存一份完整的块组描述符，浪费空间，且块组描述符的个数就决定了整个文件系统的大小，就被限制住了

**5、Meta Block Groups**

- 块组描述符表不保存所有块组的描述符，而是将块组分为多个**元块组（Meta Block Group）**，每个元块组里面的块描述符表仅包括自己的，一个元块组包含64个块组

<img src="https://img-blog.csdnimg.cn/ad7e65b77eed4ffbbb58ad7a591f2ddf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 2.3 目录的存储格式

**1、目录和普通文件**

- 相同：本身也是一个文件，也有inode，inode里面也指向一些块。

- 不同：普通文件的块保存文件数据，目录文件的块保存目录里面一项一项的**文件信息**
- 文件信息：保存这个目录下一级文件的文件名和对应的inode，通过inode找到真正的文件

2、为避免频繁读取磁盘里的目录文件，内核会把已经读过的目录文件用`目录项`这个数据结构缓存在内存，方便用户下次读取目录信息，目录项可包含目录或文件，不要惊讶于可以保存目录，目录格式的目录项里面保存的是目录里面一项一项的文件信息。

### 2.4 软链接和硬连接

<img src="https://img-blog.csdnimg.cn/119c6e8ac78243efbf93a4fad2441742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**硬链接**：老文件A被创建若干个硬链接B、C后。A、B、C三个文件的inode是相同的，所以不能跨文件系统。同时只有ABC全部删除，系统才会删除源文件。

**软链接**：相当于基于老文件A新建了个文件B，该文件B有新的inode，不过文件B内容是老文件A的路径。所以软链接可以跨文件系统。当老文件A删除后，文件B仍然存在，不过找不到指定文件了。

### 2.5 总结

<img src="https://img-blog.csdnimg.cn/bc9ae2f2498c4af6972703c89bdee346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 3 虚拟文件系统

**多层合作**

- 应用层：进程可通过**系统调用**进行文件读写操作
- 在内核，每个进程都需要为打开的文件维护一定的数据结构
- 在内核，整个系统打开的文件也需要维护一定的数据结构
- **虚拟文件系统**：Linux可支持多种文件系统，他们的实现各不相同，因此Linux内核向用户空间提供了虚拟文件系统这个统一的接口对文件系统进行操作。它提供了常见的文件系统对象模型，例如 inode、directory entry、mount 等，以及操作这些对象的方法，例如 inode operations、directory operations、file operations 等
- **真正的文件系统**：例如ext4
- 为了加快设备读写效率，需要缓存层
- 为了读写文件系统，需要通过块设备I/O层，这是文件系统层和块设备驱动的接口

<img src="https://img-blog.csdnimg.cn/c39245e3789a4014b40c3c9de468a6d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />

### 3.3 open 打开/创建文件

1、在进程里面通过open系统调用打开文件，最终调用系统调用实现`sys_open`

```c
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
......
  return do_sys_open(AT_FDCWD, filename, flags, mode);
}


long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
......
  fd = get_unused_fd_flags(flags);
  if (fd >= 0) {
    struct file *f = do_filp_open(dfd, tmp, &op);
    if (IS_ERR(f)) {
      put_unused_fd(fd);
      fd = PTR_ERR(f);
    } else {
      fsnotify_open(f);
      fd_install(fd, f);
    }
  }
  putname(tmp);
  return fd;
}
```

**2、首先获取一个没有用的文件描述符**

- 在每个进程的task_struct中，有一个指针files，类型是files_struct

```c
struct files_struct    *files;
```

- `files_struct`里面最重要的是一个**文件描述符表**，每打开一个文件，会在这个列表分配一项，下标就是**文件描述符**

```c
struct files_struct {
  ...... 
    struct file __rcu * fd_array[NR_OPEN_DEFAULT];
};
```

- 对于任何一个进程，默认情况下，文件描述符0表示`stdin`标准输入，文件描述符1表示`stdout`标准输出，文件描述符2表示`stedeer`标准错误输出；再打开的文件会从这个列表找一个空闲位置分配给它（**不是递增的**）
- 文件描述符表每一项都是指向**struct file**的指针，也就是说每打开一个文件都会有一个struct file对应

3、`do_filp_open`创建`struct file`结构

4、`fd_install`将文件描述符和这个结构关联起来















































































