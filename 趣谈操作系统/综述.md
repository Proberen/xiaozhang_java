# 0 综述

## 0.1 基本概念

<img src="https://img-blog.csdnimg.cn/2d65e96d459e4040834fd2e6fc4324b3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**1、中断事件**

- 输入设备驱动其实就是客户对接员。有时候新插上一个鼠标的时候，会弹出一个通知你安装驱动，这就是操作系统这家外包公司给你配备对接人员呢。当客户告诉对接员需求的时候，对于操作系统来讲，输入设备会发送一个中断。客户肯定希望外包公司把正在做的事情都停下来服务它。所以，**这个时候客户发送的需求就被称为中断事件（Interrupt Event）**

**2、文件管理子系统**

- 管理文件系统

**3、程序**

- QQ的二进制文件

**4、系统调用**

- 把权限敏感的操作，放到操作系统内核中，只能由操作系统来执行。进程如果需要执行，就通过**系统调用**。这样的话，这些敏感操作就收拢到操作系统层面，方便安全的把控等

**5、进程管理子系统**

- 管理进程的执行

**6、内存管理子系统**

- 在操作系统中，不同的进程有不同的内存空间，但是整个电脑内存就这么点儿，所以需要统一的管理和分配，这就需要内存管理子系统（Memory Management Subsystem）。

<img src="https://img-blog.csdnimg.cn/281ac4ab008e4537bea92519b7e629cc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

## 0.2 基本命令

![在这里插入图片描述](https://img-blog.csdnimg.cn/891166ceab7748c7bda94f6ace4062a4.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

## 0.3 系统调用

![在这里插入图片描述](https://img-blog.csdnimg.cn/7e3185fa7bf14cecabb13bfc559eafcc.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

### 0.3.1 进程管理

1、创建进程：`fork`

- 在 Linux 里要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作**父进程**（Parent Process），新的进程叫作**子进程**（Child Process）
- 当父进程调用` fork` 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的

> 既然fork是复制，就说明父进程和子进程在用户态的代码段是一模一样的，如果fork这个系统调用后面的语句都是A，则无论是父进程，还是子进程都是接下来要执行A的。
>
> 好在fork是一个系统调用，刚从内核返回的时候，由于**内核是能够区分父进程和子进程**的，因而用户态的程序代码里面，往往**通过这个返回值来判断自己是父进程还是子进程**，因为子进程如果不判断一下，是不知道自己是子进程的。这和CPU执行权也没有关系。就是代码执行完fork以后，由于父子进程的代码是一模一样的，父进程和子进程都不知道自己是哪一个，但是判断返回值就知道了。

2、操作系统在启动的时候先创建一个所有用户进程的“**祖宗进程**”

- 进程id为1的init进程是**用户态所有进程的祖宗**
- 进程id为2的kthread是**内核态所有进程的祖宗**

3、父进程查看子进程运行情况：`waitpid`

- 父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

### 0.3.2 内存管理

1、每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间

- **代码段**：对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）
- **数据段**：对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（Data Segment）
  - 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁的，这部分称为**堆**（Heap）。

2、进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，说自己马上就要用了，希望分配一部分内存给它，但是这还不代表真的就对应到了物理内存。**只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。**

### 0.3.3 文件管理

1、对于已经有的文件，可以使用`open`打开这个文件，`close`关闭这个文件；

2、对于没有的文件，可以使用`creat`创建文件；

3、打开文件以后，可以使用`lseek`跳到文件的某个位置；

4、可以对文件的内容进行读写，读的系统调用是`read`，写是`write`。

5、一切皆文件，每个文件，Linux 都会分配一个**文件描述符（File Descriptor）**，这是一个整数。**有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。**

### 0.3.4 进程通信

**1、消息队列**

- 发送不需要一段很长的数据，这种方式称为消息队列（Message Queue）。由于一个公司内的多个项目组沟通时，这个消息队列是在内核里的，我们可以通过`msgget`创建一个新的队列，`msgsnd`将消息发送到消息队列，而消息接收方可以使用`msgrcv`从队列中取消息。

**2、共享内存**

- 当两个项目组需要**交互的信息比较大**的时候，可以使用共享内存的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。大家都到这个会议室来，就可以完成沟通了。这时候，我们可以通过`shmget`创建一个共享内存块，通过`shmat`将共享内存映射到自己的内存空间，然后就可以读写了。

**3、信号量**

- 如果大家同时修改同一块数据咋办？这就需要有一种方式，让不同的人能够排他地访问，这就是信号量的机制 Semaphore。

### 0.3.5 网络通信

1、网络服务是通过套接字 **Socket** 来提供服务的。Socket 这个名字很有意思，可以作“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 Socket。

2、我们可以通过 `Socket `系统调用建立一个 Socket。**Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。**

