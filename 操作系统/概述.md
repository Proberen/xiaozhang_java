# 概述

## 特征

<img src="https://img-blog.csdnimg.cn/20210420195750208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />

### 并发

1、概念：**同一时间间隔内执行和调度多个程序的能力**

2、特点：

- 宏观上，处理机同时执行多道程序
- 微观上，处理机在多道程序间高速切换

- 关注单个处理机在多道程序间高速切换

### 共享

1、概念：**系统中的资源可以被多个并发进程共同使用**

2、有两种共享方式：

- **互斥共享**：资源称为临界资源，例如打印机等
- **同时共享**：同一时段允许多个程序同时访问共享资源

> 并发和共享互为前提
>
> - 共享要求OS中同时运行多个程序
> - 并发性难以避免地导致多道程序同时访问同一个资源

### 虚拟

1、概念：使用虚拟技术把一个物理实体转换为多个逻辑实体

2、两种虚拟技术：

- **时（时间）分复用技术**
  - 虚拟处理机技术：四核八线程
  - 虚拟设备技术：虚拟打印机
- **空（空间）分复用技术**
  - 虚拟磁盘技术：将一个硬盘虚拟出若干个卷
  - 虚拟存储器技术

### 异步

1、多道程序环境下，允许多个程序并发执行；单处理机环境下，多个程序分时交替执行

2、宏观上一气呵成，微观上走走停停

3、原因：程序执行的不可预知性

# 进程

## 概念

1、进程是资源分配的基本单位。

2、结构：

- 控制块（PCB）：识别进程的唯一标志，描述进程的基本信息和运行状态
- 数据段：存放原始数据、中间数据
- 程序段：存放在文本区域，**可被多个进程共享（同一个程序的进程）**

3、特征：

- 动态性：由创建而生，撤销而亡
- 并发性
- 独立性
- 异步性

> 和线程的区别

什么是线程？

- 进程的轻型实体，是一系列活动按照事先设定好的顺序执行的过程，是一系列指令的集合
- 是一条执行路径，不能单独存在，必须包含在进程中
- 是OS中运算调度的最小单位

为什么需要线程？

- 提高OS的并发性

区别：

- **拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
- **调度**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- **系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- **通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

**4、状态**

new、ready、blocked、running、terminated

<img src="https://img-blog.csdnimg.cn/20210420203157453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**5、进程控制**

OS通过**原语操作**实现进程控制

- 原子操作
- 在内核态执行
- 是内核三大支撑概念（中断处理、时钟管理、原语操作）之一

原语：

- 创建：create
- 阻塞：block
- 唤醒：wakeup
- 撤销：destroy

<img src="https://img-blog.csdnimg.cn/20210420203705524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:40%;" />

为了系统和用户观察和分析进程

将暂时不能运行的进程调到外存，进程状态为挂起状态（阻塞挂起、就绪挂起）

- 挂起：suspend

- 激活：active

## CPU调度

> 处理机调度：根据一定的算法和原则将处理机资源进行重新分配的过程
>
> 目的：提高资源利用率

### 评价指标

1、**周转时间**：任务结束时间—任务进入时间

2、**吞吐量**：单位时间完成的作业

### CPU调度算法

#### FCFS

1、先来先服务

2、非抢占的算法

3、优点：公平、算法实现简单

4、缺点：带权周转时间很长，对长作业有利，对短作业不利

#### SJF

1、短作业优先

2、非抢占的算法

#### SRTN

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

#### 时间片轮转

抢占式的算法

**保证响应时间**

#### 优先级调度算法

1、思想：根据任务的紧急程度决定

**2、可能导致饥饿**

#### 多级反馈队列调度算法

1、思想：折中权衡（RR+优先级调度）

2、内容：

- 设置多个按优先级排序的就绪队列
- 优先级从高到低，时间片从小到大
- 新进程采用队列降级法
  - 进入第一级队列，按FCFS分时间片
  - 没有执行完，降级
- 前面的队列不为空不执行后续队列进程

3、优点：公平、新到达进程很快响应

4、调度方式：抢占式

<img src="/Users/zhangtao/Desktop/截屏2021-04-20 下午8.51.42.png" alt="截屏2021-04-20 下午8.51.42" style="zoom:50%;" />

## 进程通信

> 进程之间的信息交换
>
> 进程是资源分配的基本单位，各进程内存空间独立

### 共享存储

1、允许多个进程共享一个给定的存储区

2、因为数据不需要在进程之间复制，所以这是最快的一种 IPC

3、分类：

- 基于共享数据结构的通信方式：效率低
- 基于共享存储区的通信方式：效率高



### 消息传递

**1、直接通信：点到点发送**

<img src="https://img-blog.csdnimg.cn/20210420205923596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**2、间接通信：广播信箱**



<img src="https://img-blog.csdnimg.cn/20210420210231671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



### 管道通信

1、半双工通信

2、用于连接读/写进程的共享文件（pipe文件），本质是内存中固定大小的缓冲区

## 进程同步

> 协调进程间的相互制约关系，使它们按照预期的方式执行的过程

### 信号量

1、通过使用OS提供的一对原语对信号量进行操作（PV操作）

2、分类：

- 整型信号量
- 记录型信号量

#### 整型信号量

用整数表示资源的数量

```java
int s = 1;
void wait(int s){
  while(s<=0){
    s=s-1;
  }
}
void signal(int s){
  s=s+1;
}
```

#### 记录型信号量

信号量为正：资源数量

信号量为负：等待线程数量

```java
int value;//剩余资源数量
Queue process L;//等待队列

void wait(Semphore S){
  S.value--;
  if(S.value<0){
    block(S.L);//阻塞
  }
}

void signal(Semphore S){
  S.value++;
  if(S.value<=0){
    wake up(S.L);//唤醒一个进程
  }
}
```

#### 实现进程互斥

初始值为1

在临界区之前执行P，在临界区之后执行V

#### 实现进程同步

初始值为0

在前操作之后执行V，在后操作之前执行P

```java
P1{
  前操作;
  V(S);
}

P2{
  P(S);
  后操作;
}
```

# 内存

> 什么是内存？

内存是用于存放数据的硬件，程序执行前需要先放到内存才能被CPU处理

> 逻辑地址

根据起始位置获得绝对地址





