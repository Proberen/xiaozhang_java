#  运行时数据区（一）

## 内存和线程

### 内存

内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。

**不同的jvm对于内存的划分方式和管理机制存在着部分差异**（对于Hotspot主要指：方法区）

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecae266df65ba?imageView2/0/w/1280/h/960/ignore-error/1" alt="jdk8以后 ，方法区就是元数据区" style="zoom:50%;" />

**JDK8的元数据区+JIT编译产物 就是JDK8以前的方法区**

### 分区

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecae9790e6eac?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

**红色：一个进程一份**

**灰色：一个线程一份**

- 每个线程：程序计数器、虚拟机栈、本地栈
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

**一般来说，jvm优化（比如垃圾回收）95%是优化堆区，5%优化的是方法区**

### Runtime

相当于运行时数据区，每个虚拟机只有一个Runtime实例

### 线程

1、**线程是一个程序里的运行单元**，JVM允许一个程序有多个线程并行的执行

2、在HotSpot JVM，**每个线程都与操作系统的本地线程直接映射**

- 当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收

3、操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，**它就会调用java线程中的run（）方法**

## 程序计数器（PC寄存器）

JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。

CPU只有把数据装载到寄存器才能够运行。

**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecaecbef6c19d?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />

### 作用

PC寄存器是用来存储**指向下一条指令的地址**，即将要执行的指令代码，由执行引擎读取下一条指令。

- 它是一块很小的内存空间，几乎可以忽略不计，也是**运行速度最快的存储区域**

- 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；
  - **如果是在执行native方法，则是未指定值（undefined）**（因为这个是java层面的寄存器，无法调用c的方法）。

- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成

- 字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令

- **它是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域**

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecaef254ef627?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />

### 常见面试问题

**1、使用PC寄存器存储字节码指令地址有什么用？**

因为CPU在不停切换不同的线程，切换回来之后需要知道接下来从哪里开始继续执行

<hr/>

**2、PC寄存器为什么被设定为线程私有？**

**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

### CPU时间片

CPU时间片即CPU分配各各个程序的时间，每个线程被分配一个时间段。称作它的时间片。

- 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 

- 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

**并行与并发的区别**

- 并行：同一时间多个线程同时执行；
- 并发：一个核快速切换多个线程，让它们依次执行，看起来像并行，实际上是并发

## 虚拟机栈

### 概述

**1、栈和堆**

栈是运行时的单位，堆是存储的单位

- 栈解决程序的**运行问题**，即程序如何执行、如何处理数据
- 堆解决数据的**存储问题**，即数据怎么放，放在哪儿

2、Java虚拟机栈是什么？

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应一次次的Java方法调用**（一个栈帧对应一个方法）**

3、生命周期与线程一致

**4、作用：主管Java程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果、并参与方法的调用和返回**

- 局部变量 vs 成员变量（属性）
- 基本数据类型变量 vs 引用类型变量（类、数组、接口）

5、优点

- **栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）**
- JVM直接对java栈的操作只有两个
  - 每个方法执行，伴随着进栈（入栈，压栈）
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题

### 栈的存储单位（栈帧）

1、每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在的

2、**方法和栈帧是一对一的关系**

3、栈帧是一个**内存区块**，是一个数据集，维系着方法执行过程中的各种数据信息

4、一条活动线程中，一个时间点上，只有一个活动栈帧

- 只有当前正在执行的栈帧才是有效的，被称为当前栈帧
- 对应的方法叫做当前方法
- 定义这个方法的类就是当前类

5、不同的线程所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个栈帧

**6、Java方法有两种返回函数的方式**

- return
- 抛出异常（没有处理这个异常）

#### 内部结构

每个栈帧中存储着：

- **局部变量表**（Local Variables）
- **操作数栈**（Operand Stack）(或表达式栈)
- 动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)
- 方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）
- 一些附加信息

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecafe0fab0cb2?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />

### 局部变量表

1、定义为一个**数字数组**，主要用于存储方法参数和定义在方法体内的局部变量

- 数据类型：8种基本数据类型、对象引用、returnAdress类型

2、**局部变量表需要的容量大小在编译期确定**，并保存在方法的Code属性的Maximum local variables数据项中

**3、局部变量表中的变量只在当前方法调用中有效，方法调用结束后自动销毁**

#### Slot

1、参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束（数组）

2、局部变量表，**最基本的存储单元是Slot(变量槽)**

3、局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。

4、在局部变量表里，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。**

- byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；
- long和double则占据两个slot。

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb1565b0252f?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

5、JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

6、当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制到局部变量表中的每一个slot上**

7、**如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。**（比如：访问long或者double类型变量）

8、如果当前帧是由**构造方法或者实例方法（非静态代码）**创建的，那么**该对象引用this将会存放在index为0的slot处**,其余的参数按照参数表顺序排列。

**总结：**

- double和long占两位索引，取前一位
- 非静态方法index为0的位置为this
- 无参构造器只有this

#### slot的重复利用

栈帧中的局部变量表中的槽位是可以重复利用的，**如果一个局部变量过了其作用域**，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

```java
private void test2() {
  int a = 0;
  {
    int b = 0;
    b = a+1;
  }
  //变量c使用之前以及经销毁的变量b占据的slot位置
  int c = a+1;
}
```

####  静态变量与局部变量

**变量分类：**

- 按照数据类型：基本数据类型、引用数据类型

- 按照类中声明的位置：
  - 成员变量：在使用前都经历过默认初始化赋值（类加载的第二阶段中的准备）
    - 类变量（静态变量）
      - 链接的准备阶段：给类变量赋值
      - 初始化阶段：给类变量显式赋值即静态代码块赋值
    - 实例变量
      - 随着对象的创建，会在堆空间中分配实例变量空间，并有默认赋值
  - 局部变量：使用前必须进行显式赋值，不然编译无法通过

#### 补充

在栈帧中，与性能调优关系最密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递

**局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**

### 操作数栈

1、**操作数栈，在方法执行过程中根据字节码指令，往栈中写入数据或者提取数据**，即入栈/出栈

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb180342dcf0?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

2、操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**

3、操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，**这个方法的操作数栈是空的**

4、每一个操作数栈都会**拥有一个明确的栈深度用于存储数值，**其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值（数组的长度是固定的）

5、栈中的任何一个元素都是可以任意的java数据类型

- 32bit的类型**占用一个栈单位深度**
- 64bit的类型**占用两个栈深度单位（long、double）**

6、操作数栈**并非采用访问索引的方式来进行数据访问**的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问

7、**如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。

8、操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。

9、另外，我们说Java虚拟机的**解释引擎是基于栈的执行引擎**,其中的栈指的就是操作数栈。



<hr/>

**结合下面的图来看一下一个方法（栈帧）的执行过程**

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb180342dcf0?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

**①15入栈；②存储15，15进入局部变量表**

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb1c4797b788?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />



**③压入8；④存储8，8进入局部变量表；**



<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb53336d048b?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />

**⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作，8和15出栈**





<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb55fd42e99f?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />

**⑦iadd操作结果23入栈；⑧将23存储在局部变量表索引为3的位置上**





<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb5802369d83?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />



#### i++和++i的区别

<img src="https://img-blog.csdnimg.cn/20210330104708298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 30%;" />







#### 栈顶缓存技术

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行疫情的执行效率**



### 动态链接

**1、帧数据区**：附加信息+动态链接+方法返回地址

2、每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接，比如`invokedynamic指令`

3、在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。

比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb779318dd20?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:67%;" />

>  为什么需要常量池？

提供符号和常量，便于指令的识别



### 方法的调用

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关

1、**静态链接**

当一个 字节码文件被装载进JVM内部时，**如果被调用的目标方法在编译期可知，**且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。

2、**动态链接**

**如果被调用的方法在编译期无法被确定下来**，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。

<hr/>

对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

**1、早期绑定**

早期绑定就是指被调用的**目标方法如果在编译期可知，且运行期保持不变**时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

**2、晚期绑定**

如果**被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法**，这种绑定方式也就被称之为晚期绑定。

随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。

Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。



<hr/>

**虚方法和非虚方法**

非虚方法

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法
- **静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**
- 其他方法称为虚方法

##### 虚拟机中提供了以下几条方法调用指令：

普通调用指令：
**1.invokestatic：调用静态方法，解析阶段确定唯一方法版本；**
**2.invokespecial：调用方法、私有及弗雷方法，解析阶段确定唯一方法版本；**
3.invokevirtual：调用所有虚方法；
4.invokeinterface：调用接口方法；

动态调用指令：
5.invokedynamic：动态解析出需要调用的方法，然后执行 .

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中**invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。**



**虚方法表**

- 在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。
- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。
- 那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的方法表也初始化完毕。



<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecb7f8233cc27?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

### 方法返回地址

**1、存放调用该方法的pc寄存器的值**

一个方法的结束，有两种方式：

- 正常执行完成
- 出现未处理的异常，非正常退出

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。

- 方法正常退出时，**被调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**
- 而通过异常退出时，返回地址是要通过**异常表**来确定，栈帧中一般不会保存这部分信息。

3、本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值也如调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

**正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。**

### 面试题

**1、举例栈溢出的情况？（StackOverflowError）**

递归调用、无限循环等

通过-Xss设置栈的大小

**2、调整栈大小，就能保证不出现溢出吗？**

不能保证， 比如：递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些

**3、分配的栈内存越大越好么？**

不是，会挤占其他线程的空间

**4、垃圾回收是否会涉及到虚拟机栈？**

不会

<img src="https://img-blog.csdnimg.cn/2021033013143825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**5、方法中定义的局部变量是否线程安全？**

 根据情况分析

- 在方法中创建，在方法中消亡是安全的
- 有返回值，return出去是不安全的
- 不是在内部产生（形参）的是不安全的

## 本地方法接口

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ecae9790e6eac?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />

### 本地方法

简单来讲，**一个Native Method就是一个java调用非java代码的接口**，

一个`Native Method`是这样一个java方法：该方法的实现由非Java语言实现，比如C。

本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C/C++程序。

### 为什么使用本地方法

**1、与java环境外交互**

有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。

**2、与操作系统交互**

JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。

**3、Sun’s Java**

Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetProority（）API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。

## 本地方法栈

1、**Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**

2、本地方法栈是线程私有的

3、允许被实现成**固定或者是可动态拓展**的内存大小（**和虚拟机栈在内存溢出方面是相同的**）

- 如果线程请求分配的栈容量超过本地方法栈**允许的最大容量**，Java虚拟机将会抛出一个StackOverFlowError异常。

- 如果本地方法栈可以**动态扩展**，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。

4、它的具体做法是Native Method Stack中登记`native方法`，在Execution Engine执行时加载本地方法库

**5、当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限**

- 本地方法可以通过本地方法接口来 **访问虚拟机内部的运行时数据区**
- 它甚至可以直接使用本地处理器中的寄存器
- 直接从本地内存的堆中分配任意数量的内存

