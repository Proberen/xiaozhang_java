# 对象实例化

## 对象的实例化

### 面试题

1、对象在JVM怎么存储的？

2、Java对象头里面有什么？

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4cbb14c0bd3~tplv-t2oaga2asx-watermark.awebp)

### 对象创建的方式

**1、new**

- 最常见的方式
- 变形1 ： Xxx的静态方法
- 变形2 ： XxBuilder/XxoxFactory的静态方法

**2、Class的newInstance（）**：反射的方式，只能调用空参的构造器，权限必须是public

**3、Constructor的newInstance（Xxx）**：反射的方式，可以调用空参、带参的构造器，权限没有要求

**4、使用clone（）** ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）

**5、使用反序列化**：从文件中、从网络中获取一个对象的二进制流

**6、第三方库Objenesis**

### 创建对象的步骤

**1、判断对象对应的类是否加载、链接、初始化**

**2、为对象分配内存**

- 如果内存规整一指针碰撞

- 如果内存不规整：
  - 虚拟机需要维护一个列表
  - 空闲列表分配

**3、处理并发安全问题**

- 采用CAS配上失败重试保证更新的原子性
- 每个线程预先分配一块TLAB

**4、初始化分配到的空间一所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用**

**5、设置对象的对象头**

**6、执行init方法进行初始化**

<hr/>

#### 1) 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（ 即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象

#### 2) 为对象分配内存

首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

- **如果内存规整，使用指针碰撞，指针移动**

  如果内存是规整的，那么虚拟机将采用的是指针碰撞法（BumpThePointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，**分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了**。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact （整理）过程的收集器时，使用指针碰撞。

- **如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配**

  如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机**维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容**。这种分配方式成为“空闲列表（Free List） ”。

**说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**

给对象的属性赋值的操作：
① 属性的默认初始化 
② 显式初始化 
③ 代码块中初始化 
④ 构造器中初始化

#### 3) 处理并发安全问题

在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：

- **CAS （ Compare And Swap ）**失败重试、**区域加锁**：保证指针更新操作的原子性；
- TLAB把内存分配的动作按照线程划分在不同的空间之中进行，**即每个线程在Java堆中预先分配一小块内存**，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+/一UseTLAB参数来 设定。

#### 4) 初始化分配到的空间

内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### 5) 设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

#### 6) 执行init方法进行初始化

在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。



**判断对象对应的类是否已经加载——》为对象分配空间——》处理并发安全问题——》初始化分配到的空间——》设置对象头——》初始化**



## 对象的内存布局

### 对象头

包括：**运行时元数据、类型指针**

**1、运行时元数据**

- 哈希值（hashcode）：地址值
- GC分代年龄
- 锁状态标志
- 线程持有的锁
- 偏向线程ID
- 偏向时间戳

**2、类型指针**

- 指向方法区对象所属的class，确定对象所属的类型

**如果创建的是数组，需要记录数组的长度**

### 实例数据

说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 

规则：

- 相同宽度的字段总被分配在一起
- **父类中定义的变量会出现在子类之前**
- 如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙

### 对齐填充

没有特别含义，占位符

### 小结

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d06baca2bf~tplv-t2oaga2asx-watermark.awebp)

## 对象的访问定位

> JVM是如何通过栈帧中的对象引用访问到内部的对象实例？

通过栈上的引用访问

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d419936de2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:33%;" />



### 对象访问的方式

#### 句柄访问

1、在Java堆开辟一个句柄池，记录**到对象实例数据的指针和到对象类型数据的指针**

2、优缺点

- 优点：在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改
- 缺点：需要专门开辟空间，浪费空间；效率较低

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4d9d0cb81f4~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />

#### 直接指针（默认）

1、优缺点

- 优点：速度快
- 缺点：对象移动时需要修改reference 

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728e4de9c0c7bc9~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />