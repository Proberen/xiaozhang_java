#  垃圾回收器

## GC分类与性能指标

### GC分类

1、按照**线程数**分：

- **串行垃圾回收器**：同一时间段只允许有一个cpu用于执行垃圾回收操作，此时工作线程被暂停，直到垃圾收集工作结束
  - 在单cpu的场合，串行垃圾回收器的性能表现优于并行回收器和并发回收器
  - **默认被应用在客户端的Client模式下的JVM**
- **并行垃圾回收器**：运用多个cpu同时执行垃圾回收，因此提升了应用的吞吐量
  - 独占式，使用STW机制

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f886ddbb6f49a?imageView2/0/w/1280/h/960/ignore-error/1" alt="1" style="zoom:50%;" />

2、按照**工作模式**分：

- **并发式垃圾回收器**：并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间
- **独占式垃圾回收器**：一旦运行就停止所有的用户线程

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f8873dadc3689?imageView2/0/w/1280/h/960/ignore-error/1" alt="2" style="zoom:50%;" />



3、按**碎片处理方式**分：

- **压缩式垃圾回收器**：会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片
  - 再分配对象空间使用：指针碰撞
- **非压缩式垃圾回收器**：不进行压缩
  - 在分配对象空间使用：空闲列表

4、按照**工作的内存空间**分：

- **年轻代垃圾回收器**
- **老年代垃圾回收器**

### 性能指标

**<span style="background: yellow;">1、吞吐量：运行用户代码的时间占总运行时间的比例</span>**

- （总运行时间：程序的运行时间 + 内存回收的时间）

2、垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例

**<span style="background: yellow;">3、暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</span>**

4、收集频率：相对于应用程序的执行，收集操作发生的频率

**<span style="background: yellow;">5、内存占用： Java堆区所占的内存大小</span>**

6、快速：一个对象从诞生到被回收所经历的时间

<hr/>

吞吐量、暂停时间、内存占用三者共同构成一个“不可能三角”，三者总体的表现会随着技术进步而越来越好，**一款优秀的收集器通常最多同时满足其中的两项。**

这三项里，暂停时间的重要性日益凸显，因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。

**简单来说，主要抓住两点：**

- **吞吐量**
- **暂停时间**

#### 吞吐量（throughput）

1、吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值

- `吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）`
- 比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%

2、这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。

#### 暂停时间（pause time）

1、“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态

- 例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。.

#### 对比

**吞吐量优先**，意味着在单位时间内，**STW的总时间最短**： 0.2 + 0.2 = 0.4

**暂停时间优先**，意味着尽可能让**单次STW的时间最短**： 0.1 + 0.1 + 0.1 + 0.1+0.1=0.5

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88838b4a0d54?imageView2/0/w/1280/h/960/ignore-error/1" alt="3" style="zoom:50%;" />

1、**高吞吐量较好**因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。

2、**低暂停时间（低延迟）较好**因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一一个交互式应用程序。

**3、不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）**

- 因为如果选择以吞吐量优先，那么必然需要**降低内存回收的执行频率**，但是这样会导致GC需要更长的暂停时间来执行内存回收。
- 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能**频繁地执行内存回收**，但这又引起了年轻代内存的缩诚和导致程序吞吐量的下降。

4、在设计（或使用） GC算法时，我们必须确定我们的目标： 一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。

**<span style="background: yellow;">5、现在标准：在最大吞吐量优先的情况下，降低停顿时间</span>**



## 不同的垃圾回收器概述

### 垃圾收集器发展史

有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection， 对应的产品我们称为Garbage Collector.

- 1999年随 JDK1.3.1一 起来的是**串行方式的Serial GC**，它是第一款GC，**ParNew垃圾收集器是Serial收集器的多线程版本**

- 2002年2月26日，**Parallel GC和Concurrent Mark Sweep GC**跟随 JDK1.4.2一起发布

- **Parallel GC在JDK6之后成为HotSpot默认GC**

- 2012年，在JDK1.7u4版本中，**G1可用**。

- 2017年，JDK9中**G1变成默认的垃圾收集器**，以替代CMS。

- 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。

  -----------分水岭------------

- 2018年9月，JDK11发布。**引入Epsilon垃圾回收器**，又被称为"No一Op （无操作） "回收器。**同时，引入ZGC**：可伸缩的低延迟垃圾回收器（Experimental）。

- 2019年3月，JDK12发布。 增强G1，自动返回未用堆内存给操作系统。同时，引入**Shenandoah GC**：低停顿时间的GC （Experimental）。

- 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。

- 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows.上的应用

### 7种经典垃圾回收器

串行回收器：Serial、Serial Old

并行回收器：ParNew、Paeallel Scavenge、Parallel Old

并发垃圾回收器：CMS、G1

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f888c00412b4c?imageView2/0/w/1280/h/960/ignore-error/1" alt="4" style="zoom:50%;" />

### 垃圾回收器和垃圾分代的关系

- 新生代收集器： Serial、 ParNew、Parallel Scavenge

- 老年代收集器： Serial Old、 Parallel Old、 CMS

- 整堆收集器（新生代+老年代）： G1

  <img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88913bd8914c?imageView2/0/w/1280/h/960/ignore-error/1" alt="5" style="zoom:67%;" />

### 垃圾回收器的组合关系

1、两个收集器间有连线，表明它们可以搭配使用： 

- Serial、Serial Old
- Serial、CMS
- ParNew、Serial Old
- ParNew、CMS
- Parallel Scavenge、Serial Old
- Parallel Scavenge、Parallel Old
- G1

2、其中Serial 0ld作为CMS 出现"Concurrent Mode Failure"失败的后 备预案。 

3、（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial Old这两个组合声明为废弃 ，并在JDK 9中完全取消了这些组合的支持，即：移除。

4、（绿色虚线）JDK 14中：弃用Parallel Scavenge和SerialOld GC组合

5、（青色虚线）JDK 14中：删除CMS垃圾回收器

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88972faa533c?imageView2/0/w/1280/h/960/ignore-error/1" alt="6" style="zoom:50%;" />

> 为什么要有很多收集器个不够吗？ 

因为Java的使用场景很多， 移动端，服务器等；所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。

### 如何查看默认的垃圾回收器

- `-XX：+PrintCommandLineFlags`： 查看命令行相关参数（包含使用的垃圾收集器）
- 使用命令行指令： `jinfo -flag  相关垃圾回收器参数   进程ID`

**JDK8：默认Parallel GC + Parallel Old GC**

**JDK9：默认G1**

## Serial回收器：串行回收

1、Jdk1.3之前回收新生代唯一的选择

2、Serial收集器是HotSpot中**client模式**下的**默认新生代垃圾回收器**

3、年轻代垃圾回收器：**Serial回收器**，采用**复制算法、串行回收、STW机制**的方式执行内存回收

4、老年代垃圾回收器：**Serial Old回收器**，采用**标记-压缩算法、串行回收、STW机制**

- Client模式下默认的老年代垃圾回收器
- Server模式下主要有两个用途：
  - 与新生代的Parallel Scavenge配合使用
  - 作为CMS的后备方案

![9](https://user-gold-cdn.xitu.io/2020/6/28/172f88af4c12170b?imageView2/0/w/1280/h/960/ignore-error/1)

这个收集器是一个**单线程的收集器**，“单线程”的意义：

- 说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作
- 它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World ）。

5、**优势**：简单高效（与其他收集器的单线程比，节省切换cpu的时间），运行在Client模式下比较适合

6、使用`+XX:+UseSerialGC`指定年轻代和老年代使用串行收集器（年轻：Serial，老年：Serial Old）

### 总结

- 这种垃圾收集器了解即可，现在已经不用串行的了，而且在限定单核cpu才可以用，现在都不是单核的了。
- 对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Javaweb应用程序中是不会采用串行垃圾收集器的。



## ParNew回收器：并行回收

1、如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。

- Par是Parallel的缩写，New： **只能处理新生代**

2、ParNew收集器除了采用**并行回收**的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。

3、ParNew收集器在年轻代中同样也是采用**复制算法、"Stop一 the一World"机制**。

**4、ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器** 

![10](https://user-gold-cdn.xitu.io/2020/6/28/172f88b5da16f393?imageView2/0/w/1280/h/960/ignore-error/1)

- 对于新生代，回收次数频繁，使用并行方式高效。

- 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）

> ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？

- ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、 多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。

- 但是在**单个CPU的环境下，ParNew收集器不比Serial收集器更高效**。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。

**5、组合方式**

- Serial old + ParNew（JDK8移除）
- CMS + ParNew（JDK14移除）

6、使用"`XX:+UseParNewGC`手动指定使用ParNew收集器执行内存回收任务，它**表示年轻代使用并行收集器，不影响老年代**

`-XX:ParallelGCThreads `限制线程数量，默认开启和CPU数据相同的线程数。





## Parallel回收器：吞吐量优先

1、HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外， Parallel Scavenge收集器同样也采用了**复制算法、并行回收和"Stop the World"机制。**

> 那么Parallel收集器的出现是否多此一举？

- 区别1：Parallel Scavenge收集器的**目标是达到一个可控制的吞吐量（Throughput）**，它也被称为吞吐量优先的垃圾收集器。
- 区别2：**自适应调节策略**

2、高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要**适合在后台运算而不需要太多交互的任务**。因此，常见在**服务器环境中使用**。例如，那些**执行批量处理、订单处理、工资支付、科学计算的应用程序**。

3、Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 **Parallel Old收集器**，用来代替老年代的Serial Old收集器（串行会拖累性能）。

<hr/>

**工作原理**

4、Parallel 0ld收集器采用了**标记一压缩算法，但同样也是基于并行回收和”Stop一the一World"机制**。

![11](https://user-gold-cdn.xitu.io/2020/6/28/172f88bd8272c80d?imageView2/0/w/1280/h/960/ignore-error/1)

在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错。

**在Java8中，默认是此垃圾收集器**

### 参数配置

- `-XX:+UseParallelGC`：手动指定 年轻代使用Parallel并行收集器执行内存回收任务。
- `-XX:+UseParallelOldGc`：手动指定老年代都是使用并行回收收集器。
  - 分别适用于新生代和老年代，默认jdk8是开启的。
  - 上面两个参数，**默认开启一个，另一个也会被开启（互相激活）**
- `-XX:ParallelGCThreads`：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
  - 在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量
  - 当CPU数量大于8个， ParallelGCThreads的值等于3+[5*CPU_ Count]/8]
- `-XX:MaxGCPauseMillis`：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒
  - 为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数
  - 对于用户来讲，停顿时间越短体验越好。但是**在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel**，进行控制
- `-XX:GCTimeRatio`：垃圾收集时间占总时间的比例（= 1 / （N + 1））用于衡量吞吐量的大小。
  - 取值范围（0， 100），**默认值99，也就是垃圾回收时间不超过1%**
  - 与前一个`-XX:MaxGCPauseMillis`参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例。
- `-XX:+UseAdaptiveSizePolicy`：设置Parallel Scavenge收集器具有**自适应调节策略**
  - 在这种模式下，**年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整**，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
  - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定**虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作**



## CMS回收器：低延迟

1、CMS（Concurrent - Mark - Sweep，并发-标记-清除）收集器：**第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作**

2、CMS收集器的关注点：**低延迟**

- 停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验

- 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其**重视服务的响应速度**，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

3、CMS的垃圾 收集算法采用**标记一清除算法，并且也会" stop一the一world"**

4、CMS 作为老年代的收集器**，新生代只能选择ParNew或者Serial收集器**

5、在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。

<hr/>

**工作原理**

![12](https://user-gold-cdn.xitu.io/2020/6/28/172f88c4cd91d748?imageView2/0/w/1280/h/960/ignore-error/1)

整个过程分为4个主要阶段：**初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段**

**1、初始标记（STW、时间短）**

工作线程因为“Stop一the一World"机制而出现暂停，这个阶段的主要任务**仅仅只是标记出GCRoots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的**速度非常快**

**2、并发标记（并发、时间长）**

**从GC Roots的直接关联对象开始遍历整个对象图的过程**，这个过程**耗时较长但是不需要停顿用户线程**，可以与垃圾收集线程一起并发运行。

**3、重新标记（STW、时间中等）**

由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了**修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

**4、并发清除（并发）**

此阶段清理**删除掉标记阶段判断的已经死亡的对象**，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的，会存在碎片问题

<hr/>

1、由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的

2、由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是**当堆内存使用率达到某一阈值时，便开始进行回收**，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。

要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：**临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。**

3、CMS收集器的垃圾收集算法采用的是**标记一清除算法**，这意味着每次执行完内存回收后不可避免地将会产生一些**内存碎片**。 那么CMS在为新对象分配内存空间时只能够选择**空闲列表（Free List） 执行内存分配。**

> 为什么不使用标记压缩算法呢？

因为清除阶段是并发的，标记压缩需要进行整理内存（会改变对象地址），这样会影响用户线程

**4、优点**

- 并发收集
- 低延迟

**5、弊端**

- 内存碎片：碎片化严重，导致无法分配大对象，提前触发full gc
- 对CPU资源敏感：在并发阶段会因为占用一部分线程导致应用程序变慢，吞吐量降低
- 无法处理浮动垃圾：可能出现“Concurrent Mode Failure" 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

### 小结

如果你想要最小化地使用内存和并行开销，请选Serial GC；
如果你想要最大化应用程序的吞吐量，请选Parallel GC；
如果你想要最小化GC的中断或停顿时间，请选CMS GC。

## G1回收器：区域化分代式

> **既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？**

原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。

**官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望**

> **为什么名字叫做Garbage First （G1）呢？**

1、因为G1是一个**并行回收器**，它**把堆内存分割为很多不相关的区域（Region）**（物理上不连续的），**使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。**

2、G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

3、由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。

4、G1 （Garbage一First） 是一款**面向服务端应用**的垃圾收集器，**主要针对配备多核CPU及大容量内存的机器**，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

5、在JDK1. 7版本正式启用，移除了Experimental的标识，**是JDK 9以后的默认垃圾回收器**，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为**“全功能的垃圾收集器”** 。

6、与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） ，在jdk8中G1 GC还不是默认的垃圾回收器，需要使用`-XX:+UseG1GC`来启用。



### 优势和缺点

与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：

**1、兼具并行与并发**

- **并行性**： G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW
- **并发性**： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

**2、分代收集**

- 从分代上看，**G1依然属于分代型垃圾回收器**，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构，上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
- **将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代**
- 和之前的各类回收器不同，它同时**兼顾年轻代和老年代**。对比其他回收器，或者工作在年轻代，或者工作在老年代；

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88d5eaac9036?imageView2/0/w/1280/h/960/ignore-error/1" alt="14" style="zoom:40%;" />

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88dad2adfacc?imageView2/0/w/1280/h/960/ignore-error/1" alt="15" style="zoom:40%;" />

**3、空间整合（针对碎片化问题）**

- CMS： “标记一清除”算法、内存碎片、若干次GC后进行一次碎片整理
- G1：将内存划分为一个个的region， 内存的回收是以region作为基本单位的。**Region之间是复制算法**，但**整体上实际可看作是标记一压缩（Mark一Compact）算法**，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

**4、可预测的停顿时间模型（即：软实时soft real一time）** 

这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

- 由于分区的原因，G1可以只选取部分区域进行内存回收，这样**缩小了回收的范围**，因此对于全局停顿情况的发生也能得到较好的控制。
- G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个**优先列表**，**每次根据允许的收集时间，优先回收价值最大的Region**。保证了G1 收集器在有限的时间内可以**获取尽可能高的收集效率**。
- 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

<hr/>

**缺点**

相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。

从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。

### 参数设置

`-XX:+UseG1GC` 手动指定使用G1收集器执行内存回收任务。

`-XX:G1HeapRegionSize` 设置每个Region的大小，**值是2的幂，范围是1MB 到32MB之间**，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。

`-XX:MaxGCPauseMillis` 设置期望达到的最大GC**停顿时间指标**（JVM会尽力实现，但不保证达到），默认值是200ms

`-XX:ParallelGCThread` 设置sTw.工作线程数的值，最多设置为8

`-XX:ConcGCThreads` 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。

`-XX:InitiatingHeapOccupancyPercent` 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。

#### 常见操作步骤

设计原则：简化JVM调优

第一步：开启G1垃圾收集器

第二步：设置堆的最大内存（-xmx、-xms）

第三步：设置最大停顿时间（`-XX:MaxGCPauseMillis`）

**G1提供三种垃圾回收模式：Young GC、Mixed GC、Full GC**

### 适用场景

1、服务端应用，具有大内存、多处理器的机器

2、需要**低GC延迟**，并具有**大堆**的应用程序提供解决方案

- 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒（ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）

**3、用来替换掉JDK1.5中的CMS收集器：**

 在下面的情况时，使用G1可能比CMS好：

- 超过50%的Java堆被活动数据占用；

- 对象分配频率或年代提升频率变化很大；

- GC停顿时间过长（长于0. 5至1秒）。

4、HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行 GC的多线程操作，而**G1 GC可以采用应用线程承担后台运行的GC工作**，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。

### Region

使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。

可以通过`-XX:G1HeapRegionSize`设定。所有的Region大小相同，且在JVM生命周期内不会被改变。

虽然还保留有新生代和老年代的概念，但**新生代和老年代不再是物理隔离的**了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。 

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88e292405e6f?imageView2/0/w/1280/h/960/ignore-error/1" alt="16" style="zoom:50%;" />

角色：

-  E：Eden区
- S：Survivor区
- O：Old区
- H：Humongous区，存储超过0.5个region的大对象
  - 默认大对象被分配给Old区，但是如果这个对象短期存在，就会对垃圾收集器造成负面影响
  - 如果一个H区装不下，就会寻找连续的H区存储
  - 为了能找到连续的H区，有时候不得不启动Full GC
  - G1的大多数行为都把H区作为老年代的一部分来看待
- 空白：未使用的内存空间

每一个分配的Region，都可以分成两个部分：**已分配的和未被分配的**。它们之间的**界限被称为top**。总体上来说，把一个对象分配到Region内，只需要简单增加top的值，这个做法实际上就是bump-the-pointer（指针碰撞），过程如下：

<img src="https://upload-images.jianshu.io/upload_images/2579123-edee235835bfb8ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/476" alt="img" style="zoom:67%;" />

Region可以说是G1回收器一次回收的最小单元，即**每一次回收都是回收N个Region**。这个N是多少，主要受到G1回收的效率和用户设置的软实时目标有关

每一次的回收，**G1会选择可能回收最多垃圾的Region进行回收**。与此同时，G1回收器会维护一个空间Region的链表。每次回收之后的Region都会被加入到这个链表中

每一次都只有一个Region处于被分配的状态中，被称为current region。**在多线程的情况下，这会带来并发的问题。G1回收器采用和CMS一样的TLABs的手段**。即为每一个线程分配一个Buffer，线程分配内存就在这个Buffer内分配。但是当线程耗尽了自己的Buffer之后，需要申请新的Buffer，这个时候依然会带来并发的问题，G1回收器采用的是CAS（Compate And Swap）操作

> 为线程分配Buffer的过程大概是：
>
> 1. 记录top值；
> 2. 准备分配；
> 3. 比较记录的top值和现在的top值，如果一样，则执行分配，并且更新top的值；否则，重复1；



### 执行步骤

1、初始标记（STW）：暂停其他线程，记录下gc roots直接引用的对象

2、并发标记：同CMS

3、最终标记（STW）：同CMS

4、筛选回收（STW）：首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿STW时间制定回收计划，**回收算法主要使用复制算法，将一个region中的存活对象复制到另外一个region中**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e960608c62274e6eaa135547320501ac~tplv-k3u1fbpfcp-watermark.image)

### G1垃圾收集分类

> 三个环节：
>
> - 年轻代GC（Young GC）
> - 老年代并发标记过程（Concurrent Marking）
> - 混合回收（Mixed GC）
> - 如果需要，单线程、独占式、高强度的Full GC还是会继续存在，针对GC的评估失败提供了一种失败保护机制，即强力回收



<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88cff30208a5?imageView2/0/w/1280/h/960/ignore-error/1" alt="13" style="zoom:50%;" />

顺时针， young gc 一> young gc + concurrent mark 一> Mixed GC顺序，进行垃圾回收

1、应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。**然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。**

2、当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。

3、标记完成马上开始**混合回收过程**，对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，**G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了**。同时，这个老年代Region是和年轻代一起被回收的。

<hr/>

**回收过程一：年轻代GC**

JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，**当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。**

**年轻代垃圾回收只会回收Eden区和Survivor区。**

YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88f5d8bec04e?imageView2/0/w/1280/h/960/ignore-error/1" alt="19" style="zoom:50%;" />

回收过程：

- **第一阶段，扫描根**

  根引用连同记忆集记录的外部引用作为扫描存活对象的入口

- **第二阶段，更新记忆集**

  处理dirty card queue中的card，更新RSet。 此阶段完成后，**记忆集可以准确的反映老年代对所在的内存分段中对象的引用**

- **第三阶段，处理记忆集**

  识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象

- **第四阶段，复制对象**

  遍历对象树

  - Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段
  - Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1
  - 达到阀值会被会被复制到Old区中空的内存分段
  - 如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间

- **第五阶段，处理引用**

  处理Soft，Weak， Phantom， Final， JNI Weak等引用

  最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

<hr/>

**回收过程二：并发标记过程**

**1、初始标记阶段**：标记从根节点直接可达的对象，这个阶段是STW的，并且会**触发一次年轻代GC**

**2、根区域扫描（Root Region Scanning）** ： G1 GC 扫描Survivor区 直接可达的老年代区域对象，并标记被引用的对象。这一过程必 须在young GC之前完成。

**3、并发标记（Concurrent Marking）**： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。

**4、再次标记（Remark）**： 由 于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。

**5、独占清理（cleanup，STW）**：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。

这个阶段并不会实际上去做垃圾的收集

**并发清理阶段：**识别并清理完全空闲的区域。

<hr/>

**回收过程三：混合回收**

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f8907bb964563?imageView2/0/w/1280/h/960/ignore-error/1" alt="20" style="zoom:50%;" />

当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。

这里需要注意：**是一部分老年代， 而不是全部老年代**。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制

<hr/>

**Full GC**

G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。

要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。

导致G1Full GC的原因可能有两个：

- Evacuation的时候没有足够的to一 space来存放晋升的对象；
- 并发处理过程完成之前空间耗尽。



### 记忆集

一个对象被不同区域引用的问题(**分代引用问题**)

> 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？

在其他的分代收集器，也存在这样的问题（ 而G1更突出）

回收新生代也不得不同时扫描老年代？

这样的话会降低MinorGC的效率；

**解决方法：**

- 无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：
- **每个Region都有一个对应的Remembered Set；**
- 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .
- 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；
- 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
- 当进行垃圾收集时，**在GC根节点的枚举范围加入Remembered Set**；就可以保证**不进行全局扫描，也不会有遗漏**。

<img src="https://user-gold-cdn.xitu.io/2020/6/28/172f88f075afe7cf?imageView2/0/w/1280/h/960/ignore-error/1" alt="18" style="zoom:50%;" />







## 总结

![21](https://user-gold-cdn.xitu.io/2020/6/28/172f890f1baad386?imageView2/0/w/1280/h/960/ignore-error/1)



**怎么选择垃圾回收器**

1、Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。

2、怎么选择垃圾收集器？

- 优先调整堆的大小让JVM自适应完成。
- 如果内存小于100M，使用串行收集器
- 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器
- 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择
- 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器

官方推荐G1，性能高。现在互联网的项目，基本都是使用G1

## ZGC回收器

ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

ZGC收集器是一款**基于Region内存布局的**，**（暂时） 不设分代的**，使用了**读屏障、染色指针和内存多重映**射等技术来实现可并发的**标记一压缩算法**的，以**低延迟为首要目标**的一款垃圾收集器。

ZGC的工作过程可以分为4个阶段：**并发标记一并发预备重分配一并发重分配一并发重映射等**

