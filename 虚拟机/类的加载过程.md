# 类的加载过程

## 概述

1、在Java中数据类型分为基本数据类型和引用数据类型。**基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载**

2、类的整个生命周期包括如下7个阶段:

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977a64c89d7047c392641647b211d386~tplv-k3u1fbpfcp-watermark.image" alt="61" style="zoom: 33%;" />

其中，验证+准备+解析=链接

从程序中类的使用过程看:

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9215e7fc89634f54ac5a77fbff1eaf9e~tplv-k3u1fbpfcp-watermark.image" alt="62" style="zoom: 33%;" />

## 加载阶段

**加载的理解**

**将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型一一类模板对象**

所谓类模板对象，其实就是Java类在JVM内存中的一个快照，**JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中**，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。

**反射的机制即基于这一基础，如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。**

<hr/>

**加载完成的操作**

加载阶段，简言之：**查找并加载类的二进制数据，生成Class的实例。**

在加载类时，Java虚拟机必须完成以下3件事情:

- 通过类的全名，获取类的二进制数据流。
- 解析类的二进制数据流为**方法区内的数据结构（Java类模型）**
- **创建java.lang.Class类的实例**，表示该类型，作为方法区这个类的各种数据的访问入口

### 获取二进制数据流

对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）

- **虚拟机可能通过文件系统读入一个class后缀的文件**（最常见）
- 读入jar、zip等归档数据包，提取类文件
- 事先存放在数据库中的类的二进制数据
- 使用类似于HTTP之类的协议通过网络进行加载
- 在运行时生成一段Class的二进制信息等

在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。

如果输入数据不是ClassFile的结构，则会抛出ClassFormatError（比如如果不是cafebabe开头，就会抛出ClassFormatError）

### 类模型与Class实例

**1、类模型的位置**

加载的类在JVM中创建相应的类结构，类结构会存储在**方法区**（JDK1.8之前：永久代；JDK1.8及之后：元空间） 

**2、Class实例的位置**

类将.class文件加载至元空间后，会**在堆中创建一个Java.lang.Class对象**，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。（instanceKlass -> mirror : Class的实例） 

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f60f27a2c764f628b0dc60dbcf9e1b4~tplv-k3u1fbpfcp-watermark.image" alt="63" style="zoom:30%;" />



**外部可以通过访问代表Order类的Class对象来获取Order的类数据结构**

Class类的构造方法是私有的，只有JVM才可以创建

**java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。**通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构:方法、字段等信息。

### 数组类的加载

创建数组类的情况稍微有些特殊，因为**数组类本身并不是由类加载器负责创建**，而是由JVM在运行时根据需要而直接创建的，但**数组的元素类型仍然需要依靠类加载器去创建**。

创建数组类（下述简称A）的过程:

- 如果数组的元素类型是引用类型（`String[]`），那么就遵循定义的加载过程递归加载和创建数组A的元素类型（加载String）；

- JVM使用指定的元素类型和数组维度来创建新的数组类

如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定

如果数组的元素类型是基本数据类型，类的可访问性将被缺省定义为public


## 链接阶段

### 验证

1、目的：保证加载的字节码是合法、合理并符合规范的

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab04b80d35714acbad1c9cb0a8a018ed~tplv-k3u1fbpfcp-watermark.image" alt="64" style="zoom:23%;" />

说明：

**1、格式验证：**和加载阶段一起运行

下面三个验证是针对方法区的类模版对象：

**2、语义检查：**查看语法是否符合规范

- 是否所有的类都有父类的存在
- 是否继承final
- 非抽象的类是否实现了抽象方法或者接口方法

**3、字节码检查**

**4、符号引用验证：**符号引用的直接引用是否存在

- 如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError.

- **此阶段在解析环节才会执行**

### 准备

**1、为类的静态变量分配内存，并初始化默认值**

**2、这里不包含基本数据类型的字段用`static final`修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。**

3、注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

4、在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行

### 解析

1、**将类、接口、字段和方法的符号引用转为直接引用**

2、**符号引用**：就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。

比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println（）方法被调用时，系统需要明确知道该方法的位置。



举例: 输出操作`System.out.println()`对应的字节码

`invokevirtual #24 <java/io/PrintStream.println>`

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2f65e2689c431b8849ae33fb44ea85~tplv-k3u1fbpfcp-watermark.image" alt="66" style="zoom:23%;" />

 

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f829cbe60348659d39267c7aaa03f6~tplv-k3u1fbpfcp-watermark.image" alt="67" style="zoom: 87%;" />



以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。**通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用**。

**2.小结**
所谓解析就是将**符号引用转为直接引用**，也就是得到类、字段、方法在内存中的**指针或者偏移量**。因此，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。

不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但**链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行**。

## 初始化阶段

**1、初始化静态变量，赋予正确的值**

**2、初始化阶段才开始执行类中定义的java程序代码**

3、重要工作：**`<clint>()`**方法

- 该方法自动生成
- **类静态变量的赋值语句+静态代码块语句**

4、父类的**`<clint>()`**方法优先于子类的**`<clint>()`**方法

> 什么情况下不生成**`<clint>()`**方法？

- 没有声明类变量、静态代码块
- 有类变量，但没有显式赋值
- 只有静态常量`static final`（在准备阶段就显式赋值了）

5、static+final搭配问题

```java
/**
 * 结论：
 * 在链接阶段的准备环节赋值的情况：
 * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行
 * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
 *
 * 在初始化阶段<clinit>()中赋值的情况：
 * 排除上述的在准备环节赋值的情况之外的情况。
 *
 * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。
 */
public class InitializationTest2 {
    public static int a = 1;//在初始化阶段<clinit>()中赋值
    public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值

    public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段<clinit>()中赋值
    public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);//在初始化阶段<clinit>()中赋值

    public static final String s0 = "helloworld0";//在链接阶段的准备环节赋值
    public static final String s1 = new String("helloworld1");//在初始化阶段<clinit>()中赋值

    public static String s2 = "helloworld2";

    public static final int NUM = 2;//字面量，在链接阶段的准备环节赋值
    public static final int NUM1 = new Random().nextInt(10);//在初始化阶段<clinit>()中赋值，编译阶段确定不了具体值
}
```

6、**`<clint>()`**线程安全性问题

虚拟机会保证一个类的**`<clint>()`**方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的**`<clint>()`**方法，其他线程都需要**阻塞等待**，直到活动线程执行**`<clint>()`**方法完毕。

正是因为**`<clint>()`**带锁线程安全的，因此，如果在一个类的**`<clint>()`**方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁，并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。

如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行**`<clint>()`**方法了。那么，当需要使用这个类时虚拟机会直接返回给它已经准备好的信息

### 类的主动使用和被动使用

#### 主动使用

**会调用类的`<clint>()`方法**

如果出现如下的情况，则会对类进行初始化操作，而**初始化操作之前的加载、验证、准备已经完成：**

1、当**创建一个类的实例**时，比如使用new关键字，或者通过反射、克隆、反序列化。

2、当**调用类的静态方法**时，即当使用了字节码invokestatic指令。

3、当**使用类、接口的静态字段**时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）

4、当**使用java.lang.reflect包中的方法反射类的方法**时。比如:Class.forName（"com.atguigu.java.Test"）

5、当**初始化子类时，如果发现其父类还没有进行过初始化**，则需要先触发其父类的初始化。

6、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。

7、当虚拟机启动时，用户需要指定一个**要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类**。

8、当初次调用 MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）

#### 被动使用

也就是说:并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。

1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化

- **当通过子类引用父类的静态变量，不会导致子类初始化**

2、通过数组定义类引用，不会触发此类的初始化

- 类作为数组的类型，如：`record[] test = new record[10];`

3、引用常量不会触发此类或接口的初始化，因为常量在链接阶段就已经被显式赋值了。

4、调用ClassLoader类的`loadClass（）`方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

## 使用

开发人员可以在程序中访问和调用它的静态类成员信息（比如:静态字段、静态方法），或者使用new关键字为其创建对象实例。

**例：加载一个类时，以Order类为例：**

- 方法区：存放Order类模板数据/对象
- 堆空间：创建一个Order类的Class实例，这个实例指向了方法区中的类模板对象
- 栈中（栈帧的局部变量表中）中：声明了一个class对象，class对象指向了堆空间中的Class实例
- Order的对象实例存放在堆中

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b042f4c4eda2497c8e85273d9fd2d699~tplv-k3u1fbpfcp-watermark.image" alt="69" style="zoom:70%;" />

## 卸载

类存在于方法区中，jdk8中方法区的落地实现是元空间，元空间使用的是系统内存，所以当类没有被及时卸载时，可能会出现方法区的OOM

### 类、类的加载器、类的实例

**1、某个类的Class实例与其类的加载器之间为双向关联关系**

- 在**类加载器的内部实现**中，用一个**Java集合来存放所加载类的引用**

- 一个Class对象总是会引用它的类加载器，调用Class对象的`getClassLoader（）`方法，就能获得它的类加载器

2、类的实例总是引用代表这个类的Class对象，在0bject类中定义了`getClass（）`方法，这个方法返回代表对象所属类的Class对象的引用。

### 类的生命周期

1、当Sample类被加载、链接和初始化后，它的生命周期就开始了。

2、当代表Sample类的Class对象不再被引用，即**不可触及时**，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。

**一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。**



<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea80ceb63f748a0b451f93dd7f31317~tplv-k3u1fbpfcp-watermark.image" alt="70" style="zoom:50%;" /> 



1、loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它

2、如果程序运行过程中，将上图左侧三个引用变量都置为`null`

- Sample对象结束生命周期
- Myclass Loader对象结束生命周期
- SampleClass类的对象也结束生命周期
- Sample类在方法区内的二进制数据被**卸载**

3、当再次有需要时，会检查Sample类的Class对象是否存在

- 如果存在会直接使用
- 如果不存在 Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表 SampleClass类的实例。

### 回顾：方法区的垃圾回收

**方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。**

HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件:

- **该类所有的实例都已经被回收**
  - 也就是Java堆中不存在该类及其任何派生子类的实例
- **加载该类的类加载器已经被回收**
  - 这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是**很难达成的**
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。

### 类的卸载

1、**启动类加载器**加载的类型在整个运行期间是**不可能被卸载**的(jvm和jls规范)

2、被**系统类加载器和扩展类加载器**加载的类型在运行期间**不太可能被卸载**，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable的可能性极小。

3、**被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，**而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。

综合以上三点，**一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的**。同时我们可以看的出来,开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。




