# MySQL

<img src="https://img-blog.csdnimg.cn/20210412230559704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" />

## 😊 问题

> 关系型数据库和非关系型数据库

<img src="https://pic1.zhimg.com/50/v2-7fbacd76b41dad4b9085eb3dc3945e36_b.jpg" alt="img" style="zoom:50%;" />

关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。

**优点：** 1、易于维护：都是使用表结构，格式一致； 2、使用方便：SQL语言通用，可用于复杂查询； 3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。

**缺点：** 1、读写性能比较差，尤其是海量数据的高效率读写； 2、固定的表结构，灵活度稍欠； 3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。

![img](https://pic4.zhimg.com/50/v2-6a00cbd7da57844cc1dba1a457d76b8b_b.jpg)

非关系型数据库严格上不是一种数据库，应该是一种**数据结构化存储方法**的集合，可以是文档或者键值对等。

**优点：** 1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。 2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘； 3、高扩展性； 4、成本低：nosql数据库部署简单，基本都是开源软件。

**缺点：** 1、不提供sql支持，学习和使用成本较高； 2、无事务处理； 3、数据结构相对复杂，复杂查询方面稍欠。

> 为什么使用B+树？

**1、哈希表：**只有精确匹配索引所有列的查询才有效，不适合范围查询

- **自适应哈希索引**：如果 InnoDB 注意到某些索引列值被频繁使用时，它会在内存基于 B+ 树索引之上再创建一个哈希索引，这样就能让 B+ 树也具有哈希索引的优点。

**2、平衡二叉树：**每个节点只存储一个键值和数据，数量非常多时树会非常高

**3、B树：**每个节点可以存储多个关键字，一定程度上解决了上文提到的存储尽量多的索引的问题，也一定程度上的解决了存储尽量多的有效索引的问题

**4、B+树：**

- **非节点不存储数据**：InnoDB 中页的默认大小是 16 KB，如果不存储数据，那么节点就可以存储更多的键值
- **B+ 树的叶子节点中的索引数据是按顺序排列的，并且叶子节点间是通过双向链表进行连接的**：实现范围查找，排序查找，分组查找等操作时变得异常简单

> 如果没有主键索引？

 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引

> 为什么推荐使用自增索引？

自增的话就是依次插入，否则就需要在已经有的节点插入，可能会有叶子节点的分裂

> 为什么不能使用红黑树？

读取磁盘的次数过多，读取浪费太多

> B+树的阶

16K / 字段大小

int：4byte

bigint：8byte

指针：6B





### 锁机制

> **面试官：你知道MySQL的锁机制吗？**

答：知道的。MySQL锁按加锁粒度可以分为行锁表锁和页锁。按锁的使用方式可以分为共享锁和排他锁。按加锁思想可以分为悲观锁和乐观锁。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9KYmlhZUtucEd1NmpHeFNVdXkxcUhVMUtJTWNOY0R6M2dFcGtpYU4yV00yaWJvQ0VqcEJ1UE9mQlcxbmxjSlZoYXlBQXowVnJzVllBV3pCOWFvOTdXeTlzQS82NDA?x-oss-process=image/format,png)

**1、行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。**

**2、表级锁是表示当前的操作对整张表加锁，资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大。**

3、在 MySQL 中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。

I**nnoDB 行锁是通过给索引项加锁实现的**，如果没有索引，InnoDB 会通过隐藏的聚簇索引来对记录加锁。也就是说：**如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样**。因为没有了索引，找到某一条记录就得扫描全表，要扫描全表，就得锁定表。

**4、乐观锁和悲观锁**

悲观锁和乐观锁是两种加锁的思想。**乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段**。

**乐观锁**在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

乐观锁主要是基于数据版本机制来实现，实现方式有两种：CAS和版本号机制。**MVCC也是乐观锁的一种实现方**式。(注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control。MVCC最大的好处是：读不加锁，读写不冲突。读分为快照读和当前读，快照读基于数据的可见版本不加锁。）


>**面试官：那乐观锁加锁吗？**

答：
（1）乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；
（2）有时乐观锁可能与加锁操作合作，但不能改变“乐观锁本身不加锁”这一事实。



> **面试官：那你知道死锁吗？是怎么产生的又怎么样解决呢？**

MySQL中的死锁一般是事务相互等待对方资源，最后形成环路造成的。若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程。

**死锁的产生主要有以下几种情况**：不同表相同记录行锁冲突，相同表记录行锁冲突，不同索引锁冲突，gap锁冲突。

死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

所以当出现死锁时要分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。同时可以通过应用业务日志定位到问题代码，找到相应的事务对应的sql。

**死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。**所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。

避免死锁的方法：

1）以固定的顺序访问表和行。

2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。

3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。

4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。







## 😊 基础

> 数据类型

**1、varchar：**可变长度的字符串，可以根据传输的数据长度动态分配空间

- 优点：节省空间
- 缺点：速度慢
- 适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。

**2、char：**定长字符串，不管实际的数据长度是多少，分配固定长度的空间，使用不恰当的时候可能会导致空间的浪费

- 优点：速度快
- 缺点：使用不当可能会导致空间的浪费
- **适合存储很短的字符串**，或所有值都接近同一个长度，例如存储密码的 MD5 值。
- 对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。

3、int：整数型，等同于java中的int

4、bigint：长整型，等同于java中的long

5、float：单精度浮点型数据

6、double：双精度浮点型数据

7、date：短日期类型

8、datetime：长日期类型

>DATETIME 和 TIMESTAMP 的区别？

**DATETIME** 能保存大范围的值，从 1001~9999 年，精度为秒。把日期和时间封装到了一个整数中，与时区无关，使用 8 字节存储空间。

**TIMESTAMP** 和 UNIX 时间戳相同，只使用 4 字节的存储空间，范围比 DATETIME 小得多，只能表示 1970 ~2038 年，并且依赖于时区。

> MySQL支持的字符集和排序规则

utf8mb3（在mysql中就是utf8）：阉割过的utf8字符集，使用1-3个字节表示字符

utf8mb4（emoji表情）：正宗的utf8字符集，使用1-4个字节表示字符

> SQL语句执行顺序

- 编写步骤
  - select
  - from
  - join on
  - where
  - group by
  - having
  - order by
  - limit

- 执行步骤

  - from
  - on join
  - where
  - group by
  - having
  - select
  - Order by
  - limit

  

## 😊 事务

> 什么是事务？

**一个事务其实就是一个完整的业务逻辑**

答：事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行，也就是说事务内的语句要么全部执行成功，要么全部执行失败。

什么是完整的业务逻辑？

- 假设从A账户向B账户转账100元，将A账户的钱减去100，将B账户的钱加100

**以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分**

**1、只有DML（insert、delete、update）语句才有事务，其他的语句和事务无关**

- 只有这三个操作对数据库表的数据进行增删改，需要考虑安全问题

> 假设所有业务只需要一条DML语句就能完成，还需要事务机制吗？

正是因为做某件事的时候需要多条DML语句共同联合完成，所以才需要事务的存在；一条DML语句不需要事务

> 到底什么是事务？

本质上，一个事务其实就是多条DML语句同时成功，或者同时失败

> 事务是怎么做到同时成功同时失败的呢？

InnoDB存储引擎：提供一组用来记录**事务性活动的日志文件**

在事务的执行过程中，每一条DML语句的操作都会记录到**事务性活动日志文件**中

在事务的执行过程中，可以提交事务，也可以回滚事务

- **提交事务**：清空事务性活动日志文件，将数据持久化到数据库表中，**标志着事务的成功结束**
- **回滚事务**：清空事务性活动日志文件，撤销所有的操作，**事务结束，全部失败**

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/640-20201207160554677.png)

> 如何提交事务？如何回滚事务？

提交事务：`commit`语句

回滚事务：`rollback`语句，回滚到上一次的提交点

事务：transaction

> mysql默认情况下是什么样的事务行为？

自动提交，每执行一条DML语句提交一次（回滚无效）

关闭自动提交机制：

```sql
start transaction;
```

**自动提交不符合开发习惯，为了保证数据的安全，所以需要使用事务**

> 事务有什么特性？ACID？

**原子性 atomicity**

一个事务在逻辑上是必须不可分割的最小工作单元，不可再分

**一致性 consistency**

同一个事物中所有操作同时成功或者同时失败

**隔离性 isolation**

A事务和B事务之间有一定的隔离

A事务在操作一张表时在提交之前对另一个事务B的隔离性

针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。

**持久性 durability**

一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。

> 事务的隔离级别

A教室和B教室之间的墙可以很厚也可以很薄，这就是事务的隔离级别，墙越厚表示隔离级别越高

事务和事务之间的隔离级别包括：

- **读未提交 READ UNCOMMITTED**：没有提交就读到了
  - 事务A可以读取到事务B未提交的数据
  - **脏读现象**：读到了脏数据
  - 这种隔离级别一般都是理论上的，大多数数据库不使用
- **读已提交 READ COMMITTED**：提交之后才能读到
  - 事务A只能读取到事务B提交后的数据
  - 解决了脏读现象
  - **问题：不可重复读取数据、幻读**
    - 事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再次读取的时候读到了4条，3不等于4称为不可重复读取
  
  > 幻读：如果一个事务先根据某些条件查询出一些记录，之后另外一个事务向表中添加了一些记录，原先的事务再次按照该条件查询的时候，读到了另外一个事务插入的数据。针对多行
  >
  > 幻读的重点在于新增或者删除
  
  > 不可重复读：如果事务A 按一定条件搜索， 期间事务B 修改了符合条件的某一条数据，导致事务A 再次读取时数据发生改变，针对一行
  >
  > 不可重复读的重点是修改
  
  - **每次读到的数据是真实的**
  - Orcale默认
- **可重复读 REPEATABLE READ**：提交之后也读不到，只能读取事务开始的数据
  - 事务A开启之后，不管多久每一次读取的数据都是一致的，即使数据已经改变
  - 解决了不可重复读取数据的问题
  - **问题：可能出现幻读**
    - 数据不够绝对真实
  - MySQL默认，mysql是不会出现幻读的
- **串行化 SERIALIZABLE**（最高隔离级别）
  - 效率低
  - 解决了所有问题
  - **事务不能并发**
  - 每一次读取到的数据都是最真实的

 ```sql
设置隔离级别
set global transaction isolation level read uncommitted;
查看全局隔离级别
select @@transaction_isolation;
 ```

> 版本链

对于InnoDB存储引擎，他的聚簇索引记录中都包含两个必要的隐藏列：

- trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id
- Roll_pointer：每次对某条记录进行改动时，这个隐藏列会存储一个指针，可以通过指针获取该记录修改前的信息

<img src="https://upload-images.jianshu.io/upload_images/10820483-d251da7ae4b62565?imageMogr2/auto-orient/strip|imageView2/2/w/675" alt="img" style="zoom:50%;" />

> ReadView

对于使用读未提交的事务来说，直接读取记录的最新版本就好了，对于使用串行的事务来说，使用枷锁方式访问记录，对于读已提交和可重复读的事务来说，就需要版本链，**核心问题是需要判断版本链哪个版本对事务可见：**

ReadView中4个重要的内容：

- m_ids：**一个列表, 存储当前系统活跃的事务id（没有提交的事务）**，通过对照版本链找到已经提交的事务

- min_trx_id：存m_ids的最小值

- max_trx_id：系统分配给下一个事务的id

- creator_trx_id:：生成readView事务的事务id

> 已提交读和可重复读的区别就在于它们生成ReadView的策略不同

也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView

可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

> MVCC

MVCC （多版本并发控制），指的是**在使用读已提交和重复读两个隔离级别的事务进行执行select操作时访问记录的版本链的过程**

MVCC 只能在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作，因为 `READ UNCOMMITTED` 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 `SERIALIZABLE` 则会对所有读取的行都加锁。

## 😊 锁

操作粒度：

- 表锁：操作时，会锁定整个表
- 行锁：操作时，会锁定当前操作行

对数据操作的类型分：

- 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响
- 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412175608445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

### MyISAM表锁

MyISAM在**执行查询语句前，会自动给涉及的所有表加读锁，在执行更新操作（update、delete、insert）前，会自动给涉及的表加写锁**，这个过程不需要用户干预。

```sql
显式加读锁：
lock table tb_book read;
```

1、对一个表使用表读锁后，不能读取另外一个表

2、读锁和写操作冲突

```sql
显示加写锁：
lock table tb_book write;
```

1、在当前客户端：加写锁可以读

2、在当前客户端：加写锁可以更新、插入

3、在其他客户端：加写锁不可以读、不可以更新和插入

**小结**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412181629938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

1、加读锁，不会阻塞其他用户的读，会阻塞写

2、加写锁，会阻塞其他用户的读和写

**MyISAM的读写锁调度是写优先，不适合作为写为主的存储引擎**

### InnoDB锁

**行锁**：偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁；锁定的粒度很小，发生锁冲突的概率最低，并发读也最高

> InnoDB和MyISAM最大的不同就是支持事务、行锁

#### 行锁的种类

**1、记录锁**：加在索引上的，不加索引就会升级为表锁

**2、间隙锁**：为了避免幻读，引入了间隙锁，锁定的是范围，**只有在事务隔离级别 RR 中才会产生**

当我们用**范围条件**而不是使用相等条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件的已有数据进行加锁，**对于键值在条件范围内但并不存在的记录叫做间隙（GAP），InnoDB会对间隙加锁**

- **非唯一索引等值判断、范围查询都会产生间隙锁**
- **主键索引等值判断存在不会产生间隙锁（不存在就会产生间隙锁，锁住上面最近的一个到下面最近的一个），返回查询会产生间隙锁**

如：查找id<8，id有1、2、3、4、6、7，会对5也进行加锁

```sql
事务1:
update city set city_name="zhang" where country_id<4;

事务2:
insert into city values(2,"hello",3);
无法执行
```

**3、记录锁和间隙锁组合（临键锁）**

封锁范围包含索引记录，又包含索引区间，主要目的是为了避免幻读

**锁定一段`左开右闭`的索引区间**

**临键锁只与`非唯一索引列`有关，在`唯一索引列`（包括`主键列`）上不存在临键锁。**

> 1、加锁语句，使用主键或唯一键进行定值查询，查询对象存在时，使用的是记录锁（行锁），查询对象不存在时，使用的是间隙锁。
>
> 2、加锁语句，使用主键或唯一键进行范围查询，使用的是间隙锁
>
> 3、加锁语句，使用普通索引进行定值或者范围查询，均使用的是间隙锁
>
> 4、间隙锁可以看做是左右开区间“（）”，而临键锁是记录锁+间隙锁，所以看做是左开右闭区间“（]”，且InnoDB默认加锁为临键锁
>
> 5、间隙锁和临建锁都是为解决幻读问题
>
> **6、记录锁、间隙锁、临键锁，都属于排它锁；**

**4、表锁**

#### 锁的类型

**1、读锁**

**对于普通select语句，InnoDB不会加任何锁**

**将查到的数据加S锁，允许其他事务继续获取这些记录的S锁，不能获取这些记录的X锁（会阻塞）**

使用场景：读出数据后，其他事务不能修改，自己也不一定能修改，因为其他事务也可以加读锁

```sql
select ... lock in share mode
```

<hr/>

**将查到的数据加上X锁，不允许其他事务获取这些记录的S锁和X锁**

使用场景：读出数据后，其他事务即不能写也不能读，只有自己可以修改数据

```sql
select ... for update
```

**2、写锁**

delete：删除一条数据时，先对记录加X锁，再执行删除操作

insert：插入一条记录时，会先加**隐式锁**来保护这条新插入的记录在本事务提交前不被别的事务访问到

update：

- 如果被更新的列，修改前后没有导致存储空间变化，会先加X锁，再进行修改
- 如果被更新的列，修改前后导致存储空间产生变化，会先加X锁，然后删除记录，再insert一条新的记录

> 在MySQL，写锁是可以读的——MVCC

**3、MDL锁**

元数据锁

表开启了一个**查询事务**后（select），会自动获得MDL锁，保证表的结构不会发生改变（添加列等）

**4、意向锁**

在mysql的innodb引擎中，**意向锁是表级锁**

- 意向共享锁（IS）：加共享锁之前必须获取该表的意向共享锁
- 意向排它锁（IX）：加排它锁之前。。。。

意向锁和MDL锁都是为了防止事务进行中，执行DDL语句导致数据不一致

#### 乐观锁和悲观锁

**共享锁和排它锁都是悲观锁**

**乐观锁：**大多数基于数据版本记录机制实现，一般给数据库表增加一个version



#### 锁等待和死锁

**1、锁等待：**一个事务过程中产生的锁，其他事务需要等待上一个事务释放他的锁，才能占用该资源

2、死锁

> 死锁的条件

- 两行记录，至少两个事务
- 事务A操作第n行数据，并加锁
- 事务B操作第m行数据，并加锁
- 事务A操作第m行数据
- 事务B操作第n行数据
- 形成死锁

**InnoDB可以自动检测死锁并回滚该事务（将持有最少行级排他锁的事务进行回滚）**

尽量不要产生死锁～～～

> 避免死锁

- **以固定的顺序访问表和行**。
- **大事务拆小**。大事务更倾向于死锁，如果业务允许，将大事务拆小。
- 在同一个事务中，尽可能做到**一次锁定所需要的所有资源**，减少死锁概率。
- **降低隔离级别**。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
- **为表添加合理的索引**。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

#### 总结

InnoDB存储引擎由于实现了行级锁定，虽然性能损耗较高，但是在整体并发处理能力方面优于MyISAM表锁，当系统高并发的情况下，InnoDB整体性能有优势。

优化建议：

- 尽可能让检索数据通过索引完成，避免行锁升级为表锁
- 合理设计索引，减少锁的范围
- 减少索引条件及索引范围，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 尽可能使用低级别事务隔离

## 😊 索引

### 概述

1、索引是帮助mysql高效获取数据的**数据结构（有序）**

- 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，**这种数据结构就是索引**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210408170016586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

- 建立索引 VS 没有建立索引
  - 没有建立索引：需要遍历
  - 建立索引：快速定位

> sql语句select * from user where name = 'jack'；

以上sql语句回去name字段上扫描

如果没有添加所以就会进行全局扫描，一个一个比对，效率较低

**mysql在查询方面主要两种方式：**

- 全局扫描
- 根据索引检索

<hr/>

> 注意

在实际中，书的目录都是排序的，因为只有排序了才能进行区间查找，**因此mysql中索引也是排序的，并且和treeset的数据结构相同（自平衡二叉树）**

**任何数据库中，主键会自动添加索引对象，在mysql中，一个字段如果有unique约束的话，也会自动创建索引对象**

任何数据库中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号

在mysql中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中，在InnoDB存储引擎中，存储在一个逻辑名称为tablespace当中，在MEMORY存储引擎当中存储在内存中。不管存储在哪里，索引在mysql中都是一个数的形式存在

<hr/>

**1、优势**

- 快速定位，降低数据库IO成本
- 通过索引列对数据进行排序，降低数据排序成本

**2、劣势**

- 索引也是一种表，需要占用磁盘空间
- 虽然索引能够提高查询效率，**同时也降低更新表的速度（mysql不仅需要保存数据，还需要保存索引文件每次更新添加了索引列的字段，都会调整因为更新带来的键值变化后的索引信息）**

<hr/>

> 什么条件下考虑给字段添加索引？

条件一：数据量庞大（因为硬件环境不同，需要测试）

条件二：该字段经常出现在where后面，以条件的形式存在，也就是说这个字段总是被扫描

条件三：该字段很少的DML操作（因为DML之后索引需要重新排序）

**建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会影响系统性能**





### 数据结构

**索引是在MySQL的存储引擎层中实现的**，所以不同的存储引擎的索引不一定完全相同，MySQL目前提供以下4种索引：

- **BTREE：最常见的索引类型，大部分索引都支持B树索引**
- Hash：只有Memory引擎支持，使用场景简单
- R-tree：是MyISAM引擎的一种特殊索引类型
- Full-tree：全文索引也是MyISAM的一种特殊索引类型

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040817373865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

如果没有特别指明，都是指B+树（**多路搜索树，并不一定是二叉树**）

其中**聚集索引、复合索引、前缀索引、唯一索引默认都是使用B+tree索引**，统称为**索引**

#### BTree 结构

BTree又叫**多路平衡搜索树**，一颗m叉的Btree特性如下：

- 树中每个节点最多包含m个孩子
- 除根节点与叶子节点以外，**每个节点至少有`[ceil(m/2)]`个孩子**（ceil：向上取整）
- **若根节点不是叶子节点，则至少有两个孩子**
- **所有的叶子节点都在同一层**
- 每个非叶子节点由**n个key和n+1个指针**组成，其中`[ceil(m/2)-1] <= n <= m-1`
  - 当key的数量大于m-1时，中间key向上分裂到父节点，两边key分裂

**例子：5叉BTree**

插入 C N G A H E K Q M F W L T Z D P  R X Y S

过程如下：

<img src="https://img-blog.csdnimg.cn/20210408175125931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" />

<img src="https://img-blog.csdnimg.cn/20210408175138499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:55%;" />

<img src="https://img-blog.csdnimg.cn/20210408175211505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:55%;" />

<img src="https://img-blog.csdnimg.cn/20210408175221531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**BTREE和二叉树相比，层级更浅，查找数据更快**

#### B+Tree 结构

是BTree的变种，B+Tree和BTree的区别：

- **n叉B+Tree最多包含n个key，而BTree最多包含n-1个**
- B+Tree的叶子节点保存所有key信息，依照key大小顺序排列
- 所有的非叶子节点都可以看作是key的索引部分

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210408180108849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

由于B+树只有叶子节点保存key信息，查询任何key都要从root走到叶子节点，索引B+Tree的查询效率更高

> B树和B+树的区别

- B 树中每个节点同时存储 key 和 data，而 B+ 树中只有叶子节点才存储 data，非叶子节点只存储 key。
- InnoDB 对 B+ 树进行了优化，**在每个叶子节点上增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+ 树**，提高区间访问的性能。

B+ 树的优点在于：

① 由于 B+ 树在非叶子节点上不含数据信息，因此在内存页中能够存放更多的 key，数据存放得更加紧密，具有**更好的空间利用率**，访问叶子节点上关联的数据也具有更好的缓存命中率。

② B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而 B 树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有 B+树好。但是 B 树也有优点，由于每个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，访问也更迅速。

#### B树和B+树的区别

1、B 树的所有节点既存放 键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。

2、B 树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

3、B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，**任何查找都是从根节点到叶子节点的过程**，叶子节点的顺序检索很明显。

#### Hash索引和B+树

**Hash 索引定位快**

Hash 索引指的就是 Hash 表，最大的优点就是能够在很短的时间内，根据 Hash 函数定位到数据所在的位置，这是 B+树所不能比的。

**Hash 冲突问题**

知道 HashMap 或 HashTable 的同学，相信都知道它们最大的缺点就是 Hash 冲突了。不过对于数据库来说这还不算最大的缺点。

**Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点。**

### 聚集索引和非聚集索引

> 聚集索引

**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**

在 Mysql 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

**聚集索引的优点**

聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

**聚集索引的缺点**

1. **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

> 非聚集索引

**非聚集索引即索引结构和数据分开存放的索引。**

**二级索引属于非聚集索引**

> MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。
>
> **非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。**

**非聚集索引的优点**

**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

**非聚集索引的缺点**

1. 跟聚集索引一样，非聚集索引也依赖于有序的数据
2. **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

这是 Mysql 的表的文件截图:

- `.frm文件`：表结构
- `.ibd文件`：索引和数据
- `.MYD文件`：数据
- `.MYI文件`：索引

![Mysql表文件截图](https://snailclimb.gitee.io/javaguide/media/pictures/database/Mysql%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E6%88%AA%E5%9B%BE.png)

> 非聚集索引一定要回表吗？

**非聚集索引不一定回表查询。**

试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。

```text
 SELECT name FROM table WHERE name='guang19';Copy to clipboardErrorCopied
```

那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。

**即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?**

```text
SELECT id FROM table WHERE id=1;Copy to clipboardErrorCopied
```

主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。

#### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。

我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。**

> 如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。
>
> 再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。





### 索引语法和分类

可以在创建表的时候创建，也可以随时增加新的索引

**创建索引**

语法：

```sql
create [] index 索引名称 on 表名(字段名,...)
```

为city表的city_name创建索引：

```sql
create index idx_city_name on city(city_name);
```

**查看索引**

```sql
show index from city\G;
```

<img src="https://img-blog.csdnimg.cn/20210408190843606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

```sql
explain select * from city where city_name='123';

添加索引前：
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | city  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |    20.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

添加索引后：
+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | city  | NULL       | ref  | idx_city_name | idx_city_name | 203     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
```

**删除索引**

```sql
drop index idx_city_name on city;
```

**索引分类**

1、单值索引：一个字段上添加索引

2、唯一索引：unique字段上添加索引，唯一性比较弱的字段上添加索引用处不大

3、复合索引：多个字段上添加索引

4、主键索引：主键上添加索引

### 索引失效

1、`select * from city where city_name like '%T';`

**即使添加了索引也不会走索引，因为模糊匹配中以`%`开头，无法使用索引进行检索**

**2、隐式类型转换**

如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。

常见的情况是在 SQL 的 **WHERE 条件中字段类型为字符串，其值为数值**，如果没有加引号那么 MySQL 不会使用索引。

**3、索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引**

**4、使用or的时候索引会失效，如果使用or要求两边的条件字段都有索引**

```sql
explain select * from city where city_name = 'zhang' or country_id=1;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | city  | NULL       | ALL  | idx_city_name | NULL | NULL    | NULL |    5 |    40.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

没有使用索引
```

**5、使用复合索引没有使用左侧的列查找**

- 复合索引：两个字段或者更多字段联合起来

  ```sql
  create index c_index on city(city_name,country_id);
  ```

- 只能使用city_name进行查找

**6、在where当中索引列参加了运算，索引失效**

**7、在where当中索引列使用了函数**

```sql
explain select * from city where lower(city_name)='london';
```

### 索引设计原则

**建立索引**

对查询频次较高且数据量比较大的表建立索引。

索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，应当挑选最常用、过滤效果最好的列的组合。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

**使用前缀索引**

索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。

**选择合适的索引顺序**

当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。

**删除无用索引**

MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A,B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。

## 😊 存储过程和函数

**1、事先经过编译并存储在数据库中的一段SQL语句的集合**

2、优势：减少应用程序和数据库之间的交互

**3、存储过程：一个没有返回值的函数**

```sql
create proceduce procedure_name ([proc_parameter])
begin
	-- sql语句
end;
```

声明语句结束符，可以自定义:

```sql
DELIMITER $$
或
DELIMITER //
```

**4、存储函数：一个有返回值的过程**

```sql
create FUNCTION name()
returns type
begin
...
end;
```

## 😊 视图

> 什么是视图？

view：站在不同的角度看待同一份数据

> 怎么创建视图对象？怎么删除？

```sql
mysql> select * from city;
+---------+-----------+------------+
| city_id | city_name | country_id |
+---------+-----------+------------+
|       1 | 武汉      |          1 |
|       2 | 沈阳      |          1 |
|       3 | NewYork   |          2 |
|       4 | London    |          2 |
+---------+-----------+------------+
4 rows in set (0.00 sec)
```

```sql
创建视图
create view myView as select * from city;
删除视图
drop view myView;
```

**注意：只有DQL查询语句才能以view形式创建**

> 视图作用？

方便、简化开发、利于维护

可以面向视图对象进行增删改查，**对视图对象进行增删改查会对原表进行操作**

```sql
// 面向视图查询
mysql> select * from myView;
+---------+-----------+------------+
| city_id | city_name | country_id |
+---------+-----------+------------+
|       1 | 武汉      |          1 |
|       2 | 沈阳      |          1 |
|       3 | NewYork   |          2 |
|       4 | London    |          2 |
+---------+-----------+------------+
4 rows in set (0.01 sec)
```

**在实际开发中，将一个特别长且多处使用的sql语句转为视图对象，会方便增删改查，并且有利于后期的维护**

**试图对象也是一个文件，在数据库中也是以文件的形式存在的，和table一样**



## 😊 数据库设计三范式

> 函数依赖？码？

函数依赖：X函数确定Y，例如：姓名->年龄这个函数依赖只在姓名唯一的情况下成立

码：k->u，k称为超码

> 什么是数据库设计范式？

数据库表的设计依据，教你怎么进行数据库表的设计

设计数据库表的时候按照以上范式进行可以避免表数据的冗余

> 什么是规范化？

通过模式分解将低级范式的关系模式转为若干高级范式关系模式的集合

> 范式直接的关系

1NF 包含 2NF 包含 3NF 包含 BCNF

<hr/>

**第一范式**

**1、要求任何一张表必须有主键，每一个字段原子性不可再分**

2、最基本的要求

<hr/>

**第二范式**

**建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖**

```sql
学生编号+教师编号     学生姓名      教师姓名
1001 001							A						D
1002 002							B						E
1003 001							C						D
1001 002							A						E	
```

不满足第二范式，A依赖1001，D依赖001，产生了部分依赖

> 有什么缺点？

1、插入异常：如果该学生没有对应的教师，插入不进去

2、删除异常：如果一个学生换了老师，那么删除的时候学生信息也被删除了

3、修改异常：修改一个需要多修改很多个

4、数据冗余，空间浪费

> 如何修改？

解决方法：分解

**为了满足第二范式，需要这样设计：**

- 使用三张表表示多对多关系：学生表、教师表、学生教师关系表

```sql
学生编号（主键） 学生姓名

老师编号（主键） 老师信息

id（主键）学生编号（外键）老师编号（外键）
```

**口诀：多对多，三张表，关系表两个外键**

<hr/>

**第三范式**

**建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖**

```sql
学生编号(pk)  学生姓名		班级编号		班级名称
 1001				   A				 01				一年一班
 1002				   B				 02			  一年二班
 1003				   C				 02				一年二班
```

以上表设计描述班级和学生的关系，一对多关系（一个教师多个学生）

> 是否满足第三范式？

班级依赖班级编号，班级编号依赖学生编号，产生传递依赖

不符合第三范式，产生数据的冗余

> 如何设计一对多？

拆分两张表：学生表、班级表

```sql
班级编号 班级名称

学生编号 学生姓名 班级编号（外键）
```

**口诀：一对多，两张表，多的表加外键**

<hr/>

**总结**

1、一对多：两张表，多的表加外键

2、多对多：三张表，关系表两个外键

3、一对一：在实际开发可能出现一张表字段过多，这个时候需要拆分表

- 没有拆分表之前，一张表，比如用户信息表
- 拆分为用户登陆信息表、用户详细信息表







## 😊 体系结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409214735169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

**1、connection Pool**：连接池组件，接收客户端发起的请求

**2、management service & utilities**：管理服务和工具组件

- SQL interface：封装sql语句
- Parser：解析器，解析客户端的请求
- optimizer：优化器
- cache & buffers：缓存

**3、Plggable storage engines**：插件式存储引擎（innoDB）

**4、存储层**：操作文件系统、日志等信息

<hr/>

1、连接层

- 客户端和链接服务，包括本地socket通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信
- 连接池，为通过安全接入的客户端提供线程

2、服务层

- 完成大多数核心功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等
- 所有的跨存储引擎的功能也在这一层实现，在该层服务器解析查询并创建内部解析书，完成优化，最后生成执行操作；select语句还会查询内部的缓存

3、引擎层

4、存储层

<img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom:30%;" />

MySQL可以分为server层和存储引擎层

1. 客户端和server端tcp握手进行连接
2. 如果你是一条查询语句，mysql8.0之前回查询缓存，mysql8.0之后就删掉了
3. server端收到你发送的sql语句，会进行分析判断你这条sql的语法属于增删改查等等
4. 分析完要执行的sql之后，就是对sql进行一些成本估计和优化
5. 执行器拿到优化完的sql，会调用存储引擎提供的接口查询具体的数据，并将满足条件的数据返回给客户端。

## 😊 存储引擎

### 概述

1、针对不同的存储需求可以选择最优的存储引擎，存储引擎就是存储数据、建立索引、更新查询数据等技术的实现方式。

**2、存储引擎是作用在表上的**

**3、默认使用innoDB，5.5版本之前使用MyISAM**

![查看MySQL提供的所有存储引擎](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/mysql-engines.png)

从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB,并且在 5.7 版本所有的存储引擎中**只有 InnoDB 是事务性存储引擎**，也就是说**只有 InnoDB 支持事务**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409221148186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

### InnoDB

**支持事务**

**行锁**

**唯一支持外键**

**存储方式不同**

#### InnoDB页

> InnoDB是一个将表数据存储到磁盘上的存储引擎，真正处理数据的过程发生在内存中，所以需要把硬盘的数据加载到内存，**但是读写磁盘的数据远低于内存**

InnoDB将数据划分为若干页，以页作为磁盘和内存之间交互的基本单位，一般是16KB。

也就是说，一次最少从磁盘读取16KB内容到内存，一次最少将内存16KB内容刷新到磁盘中

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411163308858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

#### InnoDB页目录

> 记录在页中按照主键值由小到大顺序串联成一个**单链表**，那如果我们想根据主键值查找页中的某条记录该咋办呢？

最笨的办法：从`Infimum`记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。

**这个方法在页中存储的记录数量比较少的情况用起来也没啥问题**，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以我们说这种遍历查找这是一个`笨`办法

**那么就可以使用类似书的目录**

<img src="https://img-blog.csdnimg.cn/20210411163230474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

> 存取多行数据之后，就会出现多个页，就需要另外的部分——目录页

目录页：记录页号，key为该页的最小值，value为页数

<img src="https://img-blog.csdnimg.cn/20210411164247579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

B+树：

<img src="https://img-blog.csdnimg.cn/20210411165147141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

#### 主键：聚簇索引

特点：

- 按照主键大小进行记录和页的排序
  - 数据页（叶子节点）里的记录是按照主键从小到大排序的单向链表
  - 数据页之间是按照主键大小排列的双向链表
  - B+树中同一层的页目录也是按照主键值从小到大排序的双向链表
- B+树的叶子节点存储的是完整的用户记录，就是指这个记录中存储了所有列的值

具体这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点

**在InnoDB中，聚簇索引就是数据的存储方式，所有的用户记录都存储在了叶子节点**

**优点：**

- 可以把相关数据保存在一起
- 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。
- 用覆盖索引扫描的查询可以直接使用页节点中的主键值。

**缺点：**

- 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。
- 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。
- 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。
- 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。

#### 其他索引列：二级索引

聚簇索引只能在搜索条件是主键时才能发挥作用，因为B+树的数据是按照主键进行排序的，**当我们想以别的列作为搜索条件时，可以多建几棵B+树，不同的B+树采用不同的排序规则**

二级索引和聚簇索引的不同：

- 按照指定索引列进行排序
- **叶子节点存储的不是完整的用户记录，而是索引列+主键**
- 目录项记录中不适主键+页号，变成了索引列+页号
- 对二级索引进行查找数据的时候，需要根据主键值区聚簇索引中再查找完整的用户记录，这个过程叫**回表**

> 和聚簇索引的区别？回表？

叶子节点存储索引列+主键，然后再去聚簇索引找完整的数据

#### 多个索引列：联合索引

以多个列的大小作为排序规则建立的B+树称为联合索引，本质上是二级索引

#### 索引的适用条件

**1、全值匹配**：搜索条件中的列和索引列一致的话

**2、匹配左边的列**：不用包含全部联合索引中的列，只包含左边的就行

- <span style="color:red">如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</span>

**3、匹配列前缀**：使用like语句进行模糊匹配，需要匹配前缀，例如“AS%”

**4、匹配范围值**

- 例1：name为索引，下面的操作会使用到索引，先查找name值为Asa的记录，再查找name为Barlow的记录，因为记录之间有链表，所以可以进行查询

  ```sql
  SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
  ```

- 例2：使用联合索引name、age，下面的操作，会对name进行索引查询，对于age是用不到索引的，因为name不同，无法排序

  ```sql
  SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND age > 10;
  ```

  <span style="color:red">如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引</span>

**5、精确匹配某一列并范围匹配另外一列**：对于联合索引，如果查找左边的列是精确查找，那么后面的查找就会使用到索引

**6、排序**

- 规则：按照从左到右的顺序，先按照`name`值排序，如果记录的`name`值相同，则需要按照`birthday`来排序，如果`birthday`的值相同，则需要按照`phone_number`排序，然后进行`回表`操作取出该索引中不包含的列就好了

  ```sql
  SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
  ```

- 注意：

  - 需要匹配左索引列
  - 不可以顺序逆序混用
  - where子句中不能出现非索引列

**7、分组**

#### 覆盖查询

<span style="color:red">需要回表的记录越多，使用二级索引的性能就越低</span>，甚至让某些查询宁愿使用全表扫描也不使用`二级索引`

> 那什么时候采用全表扫描的方式，什么时候使用采用`二级索引 + 回表`的方式去执行查询呢？

这个就是传说中的**查询优化器做的工作**，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用`二级索引 + 回表`的方式。

当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用`二级索引 + 回表`的方式进行查询，因为回表的记录越少，性能提升就越高。

> 覆盖索引

为了彻底告别`回表`操作带来的性能损耗，我们建议：<span style="color:red">最好在查询列表里只包含索引列</span>

#### Buffer Pool

**InnoDB结构：**

<img src="https://img-blog.csdnimg.cn/20210420111956928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

> InnoDB的缓冲池缓存什么？有什么用？

缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。

> 速度快，那**为啥不把所有数据都放到缓冲池里**？

凡事都具备两面性，抛开数据易失性不说，访问快速的反面是存储容量小：

（1）缓存访问快，但容量小，数据库存储了200G数据，缓存容量可能只有64G；

（2）内存访问快，但容量小，买一台笔记本磁盘有2T，内存可能只有16G；

因此，只能把“最热”的数据放到“最近”的地方，以“最大限度”的降低磁盘访问。











### MyISAM

1、不支持事务

2、不支持外键

3、非聚集索引

4、MySQL5.1及之前，MyISAM 是默认存储引擎

5、支持全文索引

6、不支持行锁，支持表锁

> MyISAM和InnoDB实现BTree索引方式的区别

**MyISAM**

**B+Tree叶节点的data域存放的是数据记录的地址**。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“**非聚簇索引**”。

**InnoDB**

其数据文件本身就是索引文件，其表数据文件本身就是按B+Tree组织的一个索引结构，**树的叶节点data域保存了完整的数据记录**。这个索引的key是数据表的主键，**因此InnoDB表数据文件本身就是主索引**。这被称为“**聚簇索引**（或聚集索引）”，而其余的索引都作为**辅助索引**，**辅助索引的data域存储相应记录主键的值而不是地址**，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

**总结：**

- MyISAM的B+Tree叶子节点存放的是数据记录的地址，InnoDB的叶子节点存放的是完整的数据记录
- MyISAM是非聚集索引，InnoDB是聚集索引（数据文件本身就是主索引，主键就是索引的key）
- InnoDB的其他索引都是辅助索引，叶子节点存放主键的值
- 一个表中只能有一个聚集索引，一个表中可以有多个非聚集索引

### 存储引擎的选择

1、InnoDB：默认存储引擎，用于事务处理应用程序，支持外键。如果对事务的完整性有较高要求，在并发条件下要求数据的一致性，数据操作包含很多更新、删除操作，那么就选择InnoDB

2、MyISAM：如果操作以读操作和插入操作为主，对事务的完整性和并发性要求不高，就选择MyISAM

3、MEMORY：叫所有数据存在在RAM中，在需要快速定位记录的环境下可以提供快速访问。常用于更新不频繁的小表

4、MERGE：将一系列等同于MyISAM表以逻辑方式组合在一起，作为一个对象引用。优点是突破对单个MyISAM表的大小限制

## 😊 优化SQL步骤

### 查看SQL执行频率

`show [session|global]status`提供服务器状态信息

- session 当前链接
- global 数据库上次启动至今

```sql
mysql> show status like 'com_______';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Com_binlog    | 0     |
| Com_commit    | 0     |
| Com_delete    | 0     |
| Com_import    | 0     |
| Com_insert    | 2     |
| Com_repair    | 0     |
| Com_revoke    | 0     |
| Com_select    | 3     |
| Com_signal    | 0     |
| Com_update    | 0     |
| Com_xa_end    | 0     |
+---------------+-------+
11 rows in set (0.00 sec)



mysql> show global status like 'Innodb_rows_%';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Innodb_rows_deleted  | 0     |
| Innodb_rows_inserted | 10    |
| Innodb_rows_read     | 64    |
| Innodb_rows_updated  | 4     |
+----------------------+-------+
4 rows in set (0.00 sec)
```





### 定位低效的SQL语句

**1、慢查询日志**

可以通过慢查询日志定位那些已经执行完毕的 SQL 语句

**2、show processlist**

查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实时查看 SQL 的执行情况，同时对一些锁表操作进行优化

```sql
mysql> show processlist;
+----+-----------------+-----------+---------+---------+--------+------------------------+------------------+
| Id | User            | Host      | db      | Command | Time   | State                  | Info             |
+----+-----------------+-----------+---------+---------+--------+------------------------+------------------+
|  5 | event_scheduler | localhost | NULL    | Daemon  | 395042 | Waiting on empty queue | NULL             |
| 22 | root            | localhost | demo_01 | Query   |      0 | init                   | show processlist |
+----+-----------------+-----------+---------+---------+--------+------------------------+------------------+
2 rows in set (0.00 sec)
```

当查询非常多的数据时，可以看到：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412100758997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)



### explain

通过上面的步骤查询到效率低的sql语句后，可以通过explain或者desc命令获取MySQL如何执行SELECT语句的信息，包括执行过程中表是如何连接的、链接的顺序：

查询SQL语句的执行计划

```sql
mysql> explain select * from city;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | city  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412101236723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

**id**

表示查询中执行select子句或者操作表的顺序

1、id相同代表加载表的顺序从上到下

```sql
mysql> explain select * from city,country where city.country_id = country.country_id;

+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | country | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |    2 |   100.00 | NULL                                       |
|  1 | SIMPLE      | city    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where; Using join buffer (hash join) |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
2 rows in set, 1 warning (0.01 sec)
```

2、id不同，id值越大优先级越高，越先被执行

3、id有相同，也有不同；相同的可以认为是一组，从上到下顺序执行；在所有的组中id值越大优先级越高

**select_type**

|    名称    | 描述                                                         |
| :--------: | :----------------------------------------------------------- |
|  `SIMPLE`  | 简单的select查询，不包含子查询或者union                      |
| `PRIMARY`  | 查询中包括任何复杂的子查询，最外层查询标记为该标记           |
|  `UNION`   | 第二个select出现在union之后标记为union，如果union包含在from子句的子查询外外层标记为derived |
| `DERIVED`  | 在from列表中包含的子查询                                     |
| `SUBQUERY` | 在select或where列表中包含子查询                              |

**table**

数据来源表

**type**

表的访问类型

| null   | 不访问任何表、索引，直接返回结果                             |
| ------ | ------------------------------------------------------------ |
| system | 表只有一行记录，这是const类型的特殊例子，一般不会出现        |
| const  | 通过索引一次就找到了，用于比较**主键或者unique索引，因为只匹配一行数据**，所以很快。 |
| eq_ref | 类似于ref，区别在于使用的是唯一索引，**使用主键的关联查询**，**关联查询出的记录只有一条**。常见于主键或唯一索引扫描 |
| ref    | 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问 |
| range  | 只检索给定返回的行，使用一个索引来选择行                     |
| index  | 和all的区别为index类型只是遍历了索引树，all是遍历数据文件    |
| all    | 遍历全表                                                     |

**possible_keys**

可能用到的索引

**key**

实际用到的索引

**key_len**

索引字段的长度

**rows**

扫描行的数量

**extra**

1、using filesort：使用文件排序，使用非索引字段进行order by

2、using temporary：使用临时表保存中间结果，常见于order by 和groupby

3、using index

### show profiles 分析SQL

帮助我们了解时间耗费都去哪里了

```sql
mysql> show profiles;
+----------+------------+-------------------------+
| Query_ID | Duration   | Query                   |
+----------+------------+-------------------------+
|        1 | 0.00195000 | select @@have_profiling |
|        2 | 0.00123100 | select * from city      |
+----------+------------+-------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show profile for query 2;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000888 |
| Executing hook on transaction  | 0.000021 |
| starting                       | 0.000006 |
| checking permissions           | 0.000008 |
| Opening tables                 | 0.000050 |
| init                           | 0.000005 |
| System lock                    | 0.000015 |
| optimizing                     | 0.000012 |
| statistics                     | 0.000023 |
| preparing                      | 0.000020 |
| executing                      | 0.000131 |
| end                            | 0.000004 |
| query end                      | 0.000002 |
| waiting for handler commit     | 0.000007 |
| closing tables                 | 0.000006 |
| freeing items                  | 0.000011 |
| cleaning up                    | 0.000022 |
+--------------------------------+----------+
17 rows in set, 1 warning (0.00 sec)
```

### trace分析优化器执行计划

开启trace，设置格式为JSON，并设置trace最大能够使用的内存大小

```sql
SET optimizer_trace="enabled=on",end_markers_in_json=on;
set optimizer_trace_max_mem_size=1000000;
```

执行sql语句

```sql
select * from city where country_id >0;

查看执行计划：
select * from information_schema.optimizer_trace\G;
```

## 😊 优化

### SQL优化

#### 大批量插入数据

使用load指令大量导入数据，可以提高导入的效率

对于InnoDB类型的表，有以下几种方式可以提高导入的效率：

**1、主键顺序插入**

**2、关闭唯一性校验：`set unique_checks=0`，导入后设置为1**

**3、手动提交事务：`set autocommit=0`，导入后设置为1**

#### 优化insert语句

1、多次inset合并为一条

```sql
inser into test values(1,1),(2,1),(3,1);
```

2、手动提交事务：`set autocommit=0`，插入后设置为1

#### 优化order by语句

尽量使用use index，减少额外的排序，通过索引直接返回数据

### 应用优化

#### 使用连接池

对于访问数据库来说，建立连接的代价比较昂贵，因为我们频繁创建关闭连接是比较消耗资源的，所以有必要建立数据库连接池来提高访问的性能

#### 减少对MySQL的访问

**1、避免对数据的重复检索**

**2、增加cache层**

增加缓存层来减轻数据库的负担，部分数据从数据库抽取出来放到应用端以文本方式存储，或者使用MyBatis提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据

#### 负载均衡

将固定的负载量分布到不同的服务器上，从而降低单台服务器的负载

**1、利用MySQL复制分流查询**

- 通过MySQL的**主从复制**，实现读写分离，使增删改操作走主节点，查询操作走从节点，降低单台服务器的读写压力

  <img src="https://img-blog.csdnimg.cn/20210412163032857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**2、使用分布式数据库架构**

- 适合大数据量、负载高的情况，有良好的拓展性和可用性，通过在多台服务器之间分布数据可以实现在多台服务器之间的负载均衡

#### MySQL查询缓存优化（Mysql 8已经没有了）

> 开启MySQL查询缓存，当执行完全相同的SQL语句时，服务器就会直接从缓存中读取结果，之前的缓存会失效

**操作流程**

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021041216411765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70)

1、客户端发送一条查询给服务器

2、服务器检查查询缓存，如果命中缓存，则立即返回存储在缓存中的结果，否则进入下一个阶段

3、服务端进行SQL解析、预处理、再由优化器生成对应的执行计划

4、查询执行引擎

5、返回结果

**参数配置**

1、查看当前数据库是否支持查询缓存

```sql
show variables like 'have_query_cache';
```

2、查看是否开启查询缓存

## 😊 日志

在MySQL中，有4种日志：**错误日志、二进制日志、查询日志、慢查询日志**

### 错误日志

记录了mysqld启动和停止时，已经服务器在运行过程中发生任何严重错误时的相关信息

### 二进制日志

记录了所有DDL（数据定义）语句和DML（操作）语句，不包含select查询语句

**对数据的恢复有极其重要的作用，MySQL的主从复制就是根据这个日志**

**默认没有开启**

```sql
配置文件位置：/usr/my.cnf
开启
log_bin=mysqlbin

配置二进制日志的格式
binlog_format=statement
```

#### 日志格式

**statement**

该日志格式在日志文件中记录SQL语句，每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰查看每条语句的文本

**主从复制的时候，从库会将日志解析为原文本，并在从库重新执行一次**

**row**

记录每一行数据的变更

**mixed**

默认日志格式，混合statement和row，默认使用statement，但是特殊情况下使用row

### 查询日志

记录所有操作语句

### 慢查询日志

记录了执行时间超过`long_query_time`设置值并且扫描记录数不小于min_examined_row_limit的所有SQL语句的日志，默认10s。

## 😊 MySQL复制

> 将主数据库的DDL和DML操作通过**二进制日志**传输到从库的数据库中，然后在从库上对这些日志重新执行
>
> MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现**链状复制**

### 原理

<img src="https://img-blog.csdnimg.cn/2021041222453293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjUwODk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:60%;" />

1、Master主库在事务提交时，会把数据变更作为时间Events记录在二进制日志文件binlog中

2、主库推送二进制日志给从库的中继日志Relay log

3、从库重做中继日志的时间，将改变反映自己的日志

### 优势

主库出现问题，可以快速切换到从库提供服务

可以在从库执行查询，从主库中更新，实现读写分离，降低主库访问压力

在从库执行备份















